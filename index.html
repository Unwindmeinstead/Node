<!DOCTYPE html>
<!-- 
Code Structure Overview:
index.html
│
├── <head>
│   ├── <meta> tags
│   ├── <title>
│   ├── <link> (font imports)
│   └── <style>
│       ├── Variables
│       ├── General Styles
│       ├── Card Styles
│       ├── Input/UI Elements
│       ├── Modal Styles
│       ├── Settings Panel
│       ├── Date Picker
│       └── Animations
│
├── <body>
│   ├── Settings Button
│   │
│   ├── Settings Modal
│   │   ├── Settings Sidebar
│   │   └── Settings Panels
│   │       ├── Cards Panel
│   │       ├── Display Panel
│   │       ├── Developer Panel
│   │       ├── Calendar Panel 
│   │       └── About Panel
│   │           ├── App Info
│   │           └── Knowledge Base
│   │
│   ├── Pill Bar (Main Input)
│   │   ├── Task Input
│   │   ├── Inline Category
│   │   └── Mic Button
│   │
│   ├── Card Area (Dynamic Content)
│   │
│   ├── Date Time Picker
│   │   ├── Header
│   │   ├── Calendar
│   │   ├── Time Picker
│   │   ├── Reminder Selector
│   │   └── Action Buttons
│   │
│   └── <script>
│       ├── Global Variables
│       │   ├── Theme Settings
│       │   ├── Card Settings
│       │   └── UI State Tracking
│       │
│       ├── Utility Functions
│       │   ├── formatDateTime()
│       │   ├── getCardColor()
│       │   └── getTextColorForBackground()
│       │
│       ├── Card Creation/Management
│       │   ├── createCard()
│       │   ├── setupCardDragging()
│       │   ├── reindexCards()
│       │   └── updateCardStackPositions()
│       │
│       ├── Storage Management
│       │   ├── saveCardsToStorage()
│       │   ├── loadCardsFromStorage()
│       │   └── getHighestCardIndex()
│       │
│       ├── Text Analysis
│       │   └── determineCategory()
│       │       ├── Pattern Recognition
│       │       ├── Word Analysis
│       │       ├── Context Analysis
│       │       └── Scoring System
│       │
│       ├── Date/Time Functionality
│       │   ├── showDateTimePicker()
│       │   ├── closeDateTimePicker()
│       │   ├── initializeCalendar()
│       │   └── setDateTime()
│       │
│       └── Event Listeners
│           ├── DOMContentLoaded
│           ├── Input Events
│           ├── Button Click Handlers
│           └── Touch/Mouse Events
└──
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karmote</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Light/Dark Mode Variables */
        :root {
            /* Dark mode is default */
            --bg-color: #000000;
            --text-color: #ffffff;
            --text-muted: #888888;
            --pill-border: #333333;
            --card-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            --setting-bg: #111111;
            --setting-border: #333333;
            --setting-header: #ffffff;
            --setting-text: #dddddd;
            --btn-bg: #2a2a2a;
            --btn-border: #444444;
            --modal-overlay: rgba(0, 0, 0, 0.7);
            --sidebar-bg: #2a2a2a;
            --border-color: #444;
            --input-bg: #333;
            --hover-bg: #555;
            --accent-color: #5CB8FF;
            --accent-hover: #4a9fe9;
            --button-bg: #666;
            --button-hover: #777;
        }

        body.light-mode {
            --bg-color: #f5f5f5;
            --text-color: #333333;
            --text-muted: #666666;
            --pill-border: #cccccc;
            --card-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            --setting-bg: #ffffff;
            --setting-border: #dddddd;
            --setting-header: #333333;
            --setting-text: #555555;
            --btn-bg: #eeeeee;
            --btn-border: #cccccc;
            --modal-overlay: rgba(0, 0, 0, 0.5);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: 'Poppins', sans-serif;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .pill-bar {
            position: fixed;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            width: 75%;
            max-width: 900px;
            height: 65px;
            background-color: var(--bg-color);
            border-radius: 32.5px;
            display: flex;
            align-items: center;
            padding: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--pill-border);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            z-index: 10;
        }

        .task-input {
            flex: 1;
            height: 100%;
            background: transparent;
            border: none;
            outline: none;
            padding: 0 30px;
            color: var(--text-color);
            font-size: 16px;
            font-weight: 300;
            font-family: 'Poppins', sans-serif;
            border-radius: 32.5px 0 0 32.5px;
            text-indent: 0;
            transition: padding 0.3s ease; /* Add smooth transition for padding change */
        }

        /* Only apply text-indent to the placeholder, not the actual text */
        .task-input::placeholder {
            color: var(--text-muted);
            opacity: 1;
            text-indent: 0; /* Restore original position */
            transition: opacity 0.3s ease;
        }
        
        /* Reset text-indent when input is focused */
        .task-input:focus::placeholder {
            text-indent: 0;
            transition: text-indent 0.3s ease;
        }
        
        .mic-button {
            width: 65px;
            height: 65px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
            transition: color 0.3s ease;
            border-radius: 0 32.5px 32.5px 0;
            padding-right: 5px;
        }
        
        .mic-button:hover {
            color: var(--text-color);
        }
        
        .mic-icon {
            width: 22px;
            height: 22px;
            fill: currentColor;
        }
        
        .settings-button {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.3s ease;
            border-radius: 50%;
            z-index: 10;
        }
        
        .settings-button:hover {
            color: var(--text-color);
            background-color: rgba(255, 255, 255, 0.05);
            transform: rotate(45deg);
        }
        
        .settings-icon {
            width: 22px;
            height: 22px;
            fill: currentColor;
        }

        /* Cards Container */
        .cards-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: calc(100% - 130px);
            pointer-events: none;
            perspective: 1200px;
            z-index: 5;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .cards-stack {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 480px;
            pointer-events: all;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Card Styling */
        .card {
            position: absolute;
            border-radius: 28px; /* Increased roundness */
            width: 320px;
            padding: 24px; /* Slightly more padding */
            color: var(--setting-text);
            opacity: 0;
            transform-origin: center center;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25), 0 4px 10px rgba(0, 0, 0, 0.22); /* Premium layered shadow */
            backdrop-filter: blur(5px); /* Subtle blur effect */
            -webkit-backdrop-filter: blur(5px);
            pointer-events: all;
            transform: translateX(0) scale(0.95) rotate(0deg);
            height: 480px;
            display: flex;
            flex-direction: column;
            cursor: grab;
            will-change: transform, opacity;
            animation-duration: 0.15s;
            animation-timing-function: ease-out;
            border: 1px solid rgba(255, 255, 255, 0.1); /* Subtle border */
        }
        
        /* Premium deletion animation keyframes */
        @keyframes deleteCardPremium {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(0.9);
                opacity: 0;
            }
        }

        .card.dragging {
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3) !important;
            opacity: 1 !important;
            cursor: grabbing !important;
            transform: none !important;
            transition: none !important;
            z-index: 10000 !important;
        }

        .card.positioned {
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.5s ease !important;
            transform: none !important;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .card-header-controls {
            display: flex;
            align-items: center;
            gap: 10px; /* Increased from 8px for more consistent spacing */
        }
        
        /* Unified button styles for all card header controls */
        .card-header-controls button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            padding: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.25); /* Slightly more opaque for visibility */
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            opacity: 0.85; /* Higher default opacity */
            color: rgba(0, 0, 0, 0.9); /* Darker color for better contrast */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
        }
        
        .card-header-controls button:hover {
            background: rgba(255, 255, 255, 0.35);
            transform: translateY(-1px);
            opacity: 1;
        }
        
        .card-header-controls button svg {
            width: 14px;
            height: 14px;
            stroke-width: 2.5; /* Slightly thicker lines for better visibility */
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke: rgba(0, 0, 0, 0.9); /* Darker stroke for better contrast */
            filter: drop-shadow(0px 1px 1px rgba(255, 255, 255, 0.3)); /* Subtle shadow for better visibility */
        }

        .card-header-controls .delete-card:hover {
            background-color: rgba(255, 92, 92, 0.9);
            color: white;
        }
        
        .card-header-controls .delete-card:hover svg {
            stroke: white; /* Keep the SVG stroke white on hover */
        }
        
        .card-tag {
            font-size: 12px;
            background-color: transparent; /* Remove background */
            color: rgba(0, 0, 0, 0.9); /* Darker text for better readability */
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600; /* Slightly bolder for better visibility */
            align-self: flex-start;
            display: inline-flex;
            align-items: center;
            text-shadow: 0px 1px 1px rgba(255, 255, 255, 0.2); /* Subtle text shadow */
            border: none; /* Remove border */
        }

        /* Make category icons round */
        .category-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            background: rgba(240, 240, 240, 0.35);
            border-radius: 50%;
            padding: 4px;
            margin-right: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .card-title {
            font-size: 24px;
            font-weight: 700;
            margin: 0 0 15px 0;
            line-height: 1.2;
            outline: none !important;
            padding: 2px 4px;
            border-radius: 6px;
            transition: color 0.2s ease;
            text-shadow: 0px 1px 2px rgba(0, 0, 0, 0.2); /* Add subtle text shadow for better readability */
            color: rgba(0, 0, 0, 0.85); /* Darken text color slightly for better contrast */
            border: none !important;
        }

        .card-title:focus {
            background-color: transparent !important;
            outline: none !important;
            box-shadow: none !important;
            border: none !important;
        }
        
        .card-title:hover, .card-title:active {
            background-color: transparent !important;
            outline: none !important;
        }

        .card.collapsed .card-title {
            margin-bottom: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card.collapsed .task-list-container,
        .card.collapsed .add-step,
        .card.collapsed .card-footer {
            display: none;
        }

        .card.collapsed {
            height: auto !important;
            min-height: 80px;
            padding-bottom: 10px;
        }

        .task-list-container {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            position: relative;
            padding-right: 5px;
            mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, black 85%, transparent 100%);
        }

        .task-list {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .task-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            transition: opacity 0.2s ease, height 0.2s ease, margin-bottom 0.2s ease, padding-bottom 0.2s ease;
        }

        .task-checkbox {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-right: 10px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            background-color: rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
        }

        .task-checkbox:checked {
            background-color: rgba(0, 0, 0, 0.7);
            border-color: transparent;
        }

        .task-checkbox:checked::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 6px;
            width: 4px;
            height: 9px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        .task-text {
            flex: 1;
            font-size: 14px;
            font-weight: 500; /* Slightly bolder for better readability */
            color: rgba(0, 0, 0, 0.85); /* Darker text for better contrast */
            transition: all 0.2s ease;
            word-break: break-word;
            outline: none;
            padding: 2px 5px;
            text-shadow: 0px 1px 1px rgba(255, 255, 255, 0.15); /* Subtle text shadow */
        }

        .task-text:focus {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .task-checkbox:checked + .task-text {
            text-decoration: line-through;
            opacity: 0.6;
        }

        .delete-task {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.5);
            border: none;
            cursor: pointer;
            color: #555;
            opacity: 0;
            transition: all 0.2s ease;
            border-radius: 50%;
            margin-left: 8px;
        }

        .task-item:hover .delete-task {
            opacity: 0.7;
        }

        .delete-task:hover {
            opacity: 1 !important;
            background-color: rgba(255, 92, 92, 0.9);
            color: white;
        }

        .task-list-container::-webkit-scrollbar {
            width: 4px;
        }

        .task-list-container::-webkit-scrollbar-track {
            background: transparent;
        }

        .task-list-container::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .empty-task-list {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: rgba(0, 0, 0, 0.4);
            font-size: 14px;
            text-align: center;
            padding: 20px;
        }

        .empty-task-list svg {
            width: 32px;
            height: 32px;
            margin-bottom: 10px;
            stroke: rgba(0, 0, 0, 0.3);
        }

        .add-step {
            background: transparent;
            border: 1px dashed rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Poppins', sans-serif;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            color: rgba(0, 0, 0, 0.7);
            width: 100%;
            margin-bottom: 15px;
        }

        .add-step svg {
            margin-right: 6px;
            width: 14px;
            height: 14px;
        }

        .add-step:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .color-picker {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
            transition: transform 0.2s ease;
            overflow: hidden;
            background-size: cover !important; /* Ensure gradients display properly */
        }

        .color-picker:hover {
            transform: scale(1.1);
        }

        .card-timestamp {
            font-size: 12px;
            color: rgba(0, 0, 0, 0.7);
            font-weight: 500;
            text-align: right;
        }

        .delete-card, .toggle-collapse, .card-complete-button, .card-priority-flag, .card-due-date {
            /* These properties are now handled by the unified .card-header-controls button styles */
            z-index: 2;
        }
        
        /* Remove redundant hover rules since they're now covered by the unified button styles */
        
        .card-priority-flag.card-priority-high {
            color: #e53935;
            background-color: rgba(229, 57, 53, 0.2);
        }
        
        .card-priority-flag.card-priority-medium {
            color: #fb8c00;
            background-color: rgba(251, 140, 0, 0.2);
        }
        
        .card-priority-flag.card-priority-low {
            color: #43a047;
            background-color: rgba(67, 160, 71, 0.2);
        }
        
        .scroll-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.05));
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .task-list-container.scrollable .scroll-indicator {
            opacity: 1;
        }

        /* Notification Popup */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            text-align: center;
            pointer-events: none;
        }

        .notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .notification-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 8px;
            vertical-align: middle;
            fill: #FFCC5C;
        }

        /* Responsive styles */
        @media (max-width: 768px) {
            .pill-bar {
                width: 85%;
                height: 60px;
                bottom: 25px;
            }
            
            .task-input {
                font-size: 15px;
                padding: 0 20px;
            }
            
            .mic-button {
                width: 60px;
                height: 60px;
            }
            
            .mic-icon {
                width: 20px;
                height: 20px;
            }

            .cards-stack {
                max-width: 700px;
            }
            
            .card {
                width: 280px;
                height: 450px;
            }
        }
        
        @media (max-width: 480px) {
            .pill-bar {
                width: 92%;
                height: 55px;
                bottom: 20px;
            }
            
            .task-input {
                font-size: 14px;
                padding: 0 15px;
            }
            
            .mic-button {
                width: 55px;
                height: 55px;
            }
            
            .mic-icon {
                width: 18px;
                height: 18px;
            }
            
            .settings-button {
                top: 15px;
                right: 15px;
                width: 35px;
                height: 35px;
            }
            
            .settings-icon {
                width: 18px;
                height: 18px;
            }

            .cards-stack {
                max-width: 500px;
            }

            .card {
                width: 260px;
                height: 420px;
            }
            
            .card-title {
                font-size: 20px;
            }

            .notification {
                width: 85%;
                font-size: 13px;
                padding: 10px 15px;
            }
        }

        /* Settings Modal */
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-overlay);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .settings-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .settings-content {
            width: 1000px;
            max-width: 90%;
            height: 80vh;
            max-height: 800px;
            background-color: var(--setting-bg);
            background-image: linear-gradient(to bottom, rgba(30, 30, 30, 0.2), rgba(0, 0, 0, 0.5));
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            border: 1px solid var(--setting-border);
            position: relative;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        
        .settings-modal.show .settings-content {
            transform: scale(1);
        }
        
        .settings-close-x {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            background-color: transparent;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            transition: all 0.2s ease;
        }
        
        .settings-close-x:hover {
            color: var(--text-color);
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Category indicator in input bar */
        .category-indicator {
            position: absolute;
            top: -28px;
            right: 20px;
            padding: 4px 10px;
            border-radius: 12px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            opacity: 0.9;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            z-index: 5;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        /* New inline category indicator */
        .inline-category {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            color: var(--text-color);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            z-index: 2;
            pointer-events: none;
            visibility: hidden; /* Ensures it's completely hidden when not active */
        }
        
        .inline-category:after {
            content: "•";
            margin-left: 8px;
            opacity: 0.7;
        }
        
        .inline-category.active {
            opacity: 1;
            visibility: visible; /* Make visible when active */
        }
        
        /* Adjust input padding when category is shown */
        .task-input.with-category {
            padding-left: 110px; /* Make room for the category indicator */
        }
        
        /* Fancy animation for the category change */
        @keyframes categoryPulse {
            0% { transform: translateY(-50%) scale(0.95); opacity: 0.2; }
            50% { transform: translateY(-50%) scale(1.05); opacity: 1; }
            100% { transform: translateY(-50%) scale(1); opacity: 1; }
        }
        
        .inline-category.animate {
            animation: categoryPulse 0.4s ease forwards;
        }

        /* Two column layout */
        .settings-sidebar {
            width: 240px;
            height: 100%;
            background-color: #1a1a1a; /* Dark grey - adjust as needed */
            border-right: 1px solid var(--setting-border);
            display: flex;
            flex-direction: column;
            color: #e0e0e0;
        }
        
        /* Category icons in card tags */
        .category-icon {
            vertical-align: middle;
            margin-right: 5px;
            stroke: currentColor;
        }
        
        /* Reminder card specific styles */
        .card-type-reminder .reminder-datetime {
            margin: 5px 15px 15px;
            padding: 8px 12px;
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .card-type-reminder .reminder-date,
        .card-type-reminder .reminder-time {
            display: inline-block;
            margin-right: 10px;
            font-weight: 500;
        }
        
        .card-type-reminder .date-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease;
        }
        
        .card-type-reminder .date-item svg {
            margin-right: 12px;
            stroke: rgba(255, 255, 255, 0.9);
        }
        
        .card-type-reminder .date-text {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.9);
            outline: none;
        }
        
        /* Note card specific styles */
        .card-type-note .note-content {
            margin: 0 15px 15px;
            padding: 12px;
            min-height: 120px;
            max-height: 300px;
            overflow-y: auto;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.9);
            outline: none;
        }
        
        .card-type-note .note-content:empty:before {
            content: attr(placeholder);
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            pointer-events: none;
            display: block;
        }
        
        /* Idea card specific styles */
        .card-type-idea .task-list-container {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 10px;
        }
        
        .card-type-idea .add-step {
            background-color: rgba(255, 255, 255, 0.15);
        }
        
        /* Goal card specific styles */
        .card-type-goal .task-checkbox:checked + .task-text {
            text-decoration: line-through;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .card-type-goal .task-item {
            border-left: 3px solid rgba(255, 255, 255, 0.2);
            padding-left: 12px;
        }
        
        /* Meeting card specific styles */
        .card-type-meeting .task-item:before {
            content: "•";
            font-size: 18px;
            display: inline-block;
            margin-right: 8px;
            vertical-align: middle;
            color: rgba(255, 255, 255, 0.7);
        }
        
        /* Work card specific styles */
        .card-type-work .task-text {
            font-weight: 500;
        }
        
        /* Travel card specific styles */
        .card-type-travel .task-item {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            margin-bottom: 10px;
        }
        
        /* Make all category type cards work with the existing functionality */
        .card[class*="card-type-"] .card-title {
            margin-bottom: 10px;
        }

        .settings-logo {
            padding: 24px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--setting-header);
            font-weight: 600;
            font-size: 18px;
            border-bottom: 1px solid var(--setting-border);
        }

        .settings-logo svg {
            stroke: var(--setting-header);
        }

        .settings-nav {
            flex: 1;
            padding: 20px 0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 20px;
            background: transparent;
            border: none;
            text-align: left;
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .nav-item svg {
            stroke: var(--text-muted);
            transition: stroke 0.2s ease;
        }

        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
            color: var(--text-color);
        }

        .nav-item:hover svg {
            stroke: var(--text-color);
        }

        .nav-item.active {
            color: var(--text-color);
            background-color: rgba(255, 255, 255, 0.08);
        }

        .nav-item.active svg {
            stroke: var(--text-color);
        }

        .nav-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 3px;
            background-color: #5CB8FF;
        }

        .settings-footer {
            padding: 20px;
            border-top: 1px solid var(--setting-border);
        }

        .close-settings-btn {
            width: 100%;
            padding: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background-color: var(--btn-bg);
            border: 1px solid var(--btn-border);
            border-radius: 8px;
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .close-settings-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Settings Main Content */
        .settings-main {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            position: relative;
        }

        .settings-panel {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .settings-panel.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .settings-panel h2 {
            font-size: 24px;
            font-weight: 700;
            color: var(--setting-header);
            margin: 0 0 30px 0;
        }

        .setting-group {
            margin-bottom: 36px;
            max-width: 600px;
        }

        .setting-group h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--setting-header);
            margin: 0 0 12px 0;
        }

        .setting-description {
            margin-bottom: 15px;
            color: var(--text-muted);
            font-size: 14px;
            line-height: 1.5;
        }

        /* Theme Options */
        .theme-options {
            display: flex;
            gap: 16px;
        }

        .theme-option {
            flex: 1;
            padding: 16px;
            border-radius: 12px;
            background-color: var(--btn-bg);
            border: 1px solid var(--btn-border);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
            max-width: 160px;
        }

        .theme-option:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .theme-option.active {
            border-color: #5CB8FF;
            background-color: rgba(92, 184, 255, 0.1);
        }

        .option-preview {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .option-preview.dark {
            background-color: #121212;
            border: 1px solid #333;
        }

        .option-preview.dark svg {
            stroke: #5CB8FF;
        }

        .option-preview.light {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
        }

        .option-preview.light svg {
            stroke: #333;
        }

        .theme-option span {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-color);
        }

        /* Slider Control */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 8px;
        }

        .slider-label {
            font-size: 14px;
            color: var(--text-color);
            font-weight: 500;
        }

        .slider-label:last-child {
            font-size: 18px;
        }

        .slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--btn-border);
            outline: none;
            border-radius: 2px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #5CB8FF;
            cursor: pointer;
            border: 2px solid var(--setting-bg);
        }

        .slider-value {
            text-align: center;
            font-size: 14px;
            color: var(--text-muted);
            font-weight: 500;
        }

        /* Buttons */
        .button-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .setting-button {
            padding: 12px 16px;
            border-radius: 8px;
            background-color: var(--btn-bg);
            border: 1px solid var(--btn-border);
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-button svg {
            stroke: var(--text-color);
        }

        .setting-button:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .setting-button.warning {
            color: #ff6b6b;
            border-color: rgba(255, 107, 107, 0.3);
        }

        .setting-button.warning svg {
            stroke: #ff6b6b;
        }

        .setting-button.warning:hover {
            background-color: rgba(255, 107, 107, 0.1);
        }

        /* Select Input */
        .select-container {
            position: relative;
            max-width: 200px;
        }

        .settings-select {
            width: 100%;
            padding: 12px 16px;
            border-radius: 8px;
            background-color: var(--btn-bg);
            border: 1px solid var(--btn-border);
            color: var(--text-color);
            font-family: 'Poppins', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 16px;
        }

        .settings-select:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .settings-select:focus {
            outline: none;
            border-color: #5CB8FF;
        }

        /* Checkbox */
        .checkbox-container {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
        }

        .settings-checkbox {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border: 1px solid var(--btn-border);
            border-radius: 4px;
            margin-right: 12px;
            position: relative;
            background-color: var(--btn-bg);
            cursor: pointer;
        }

        .settings-checkbox:checked {
            background-color: #5CB8FF;
            border-color: #5CB8FF;
        }

        .settings-checkbox:checked::after {
            content: "";
            position: absolute;
            top: 3px;
            left: 7px;
            width: 4px;
            height: 9px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        .checkbox-container label {
            font-size: 14px;
            color: var(--text-color);
            cursor: pointer;
        }

        /* About Section */
        .about-app {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-bottom: 30px;
        }

        .app-logo {
            margin-bottom: 15px;
        }

        .app-logo svg {
            stroke: var(--text-color);
        }

        .about-app h3 {
            font-size: 20px;
            margin: 0 0 5px 0;
            font-weight: 700;
        }

        .version {
            color: var(--text-muted);
            margin: 0 0 15px 0;
            font-size: 14px;
        }

        .about-description {
            color: var(--text-color);
            font-size: 15px;
            max-width: 400px;
            line-height: 1.5;
        }

        .credits {
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            margin-top: 40px;
        }

        .copyright {
            margin-top: 5px;
            font-size: 12px;
        }

        /* Responsive Settings for smaller screens */
        @media (max-width: 768px) {
            .settings-content {
                width: 95%;
                height: 95vh;
                flex-direction: column;
            }
            
            .settings-sidebar {
                width: 100%;
                padding: 15px 10px;
                height: auto;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                flex-direction: row;
                justify-content: flex-start;
            }
            
            .settings-logo {
                padding: 15px;
            }
            
            .settings-nav {
                flex-direction: row;
                padding: 10px;
                overflow-x: auto;
                justify-content: flex-start;
            }
            
            .nav-item {
                flex-direction: column;
                padding: 10px;
                gap: 5px;
                width: 80px;
                text-align: center;
                font-size: 12px;
            }
            
            .nav-item.active::before {
                left: 0;
                top: auto;
                bottom: 0;
                height: 3px;
                width: 100%;
            }
            
            .settings-footer {
                display: flex;
                justify-content: center;
                margin-top: 20px;
            }
            
            .settings-main {
                padding: 20px 15px;
                position: relative;
            }
            
            .theme-options {
                flex-direction: column;
                align-items: center;
            }
            
            .theme-option {
                width: 100%;
                max-width: none;
                flex-direction: row;
                justify-content: flex-start;
            }
        }

        /* Global transition for theme changes */
        * {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* Travel card specific styles */
        .card-type-travel .task-item {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            margin-bottom: 10px;
        }
        
        /* Make all category type cards work with the existing functionality */
        .card[class*="card-type-"] .card-title {
            margin-bottom: 10px;
        }
        
        /* Completed card styles */
        .card.completed {
            opacity: 0.8;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            transform: scale(0.9);
        }
        
        .card.completed::before {
            content: "✓";
            position: absolute;
            top: -10px;
            right: -10px;
            width: 30px;
            height: 30px;
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 5;
        }
        
        .card.completed .card-title {
            text-decoration: line-through;
            opacity: 0.75;
        }
        
        .card.completed .task-list-container {
            opacity: 0.7;
        }
        
        /* Completed cards section */
        .completed-cards-section {
            position: fixed;
            bottom: 120px;
            right: 20px;
            width: 300px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            padding: 15px;
            display: none; /* Hide by default - will be shown by JS when needed */
            flex-direction: column;
            align-items: center;
            z-index: 5;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            cursor: move; /* Indicate it's draggable */
        }
        
        .completed-cards-section.dragging {
            opacity: 0.8;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        
        .completed-section-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move; /* Make sure header also shows drag cursor */
        }
        
        .drag-handle {
            display: flex;
            align-items: center;
            margin-right: 10px;
            color: rgba(255, 255, 255, 0.5);
            transition: color 0.2s ease;
        }
        
        .completed-section-header:hover .drag-handle {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .completed-section-title {
            font-size: 16px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .completed-cards-count {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .completed-cards-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
            transition: max-height 0.3s ease;
        }
        
        .completed-cards-container.collapsed {
            max-height: 0;
            overflow: hidden;
        }
        
        .collapse-completed-section {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .collapse-completed-section:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
        }
        
        .completed-cards-section .card {
            margin: 0 0 10px 0;
            position: relative !important;
            left: 0 !important;
            top: 0 !important;
            width: 100%;
            max-width: 280px;
            transform: none !important;
            opacity: 0.85 !important;
            transition: all 0.3s ease;
        }
        
        .completed-cards-section .card.collapsed {
            height: 60px;
        }
        
        .card-complete-button {
            /* Remove absolute positioning to allow it to be part of the flex layout */
            position: static;
            top: auto;
            right: auto;
            width: 28px; /* Match the other buttons */
            height: 28px; /* Match the other buttons */
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.15); /* Match the other buttons */
            border: none;
            border-radius: 4px; /* Match the other buttons */
            cursor: pointer;
            color: #000; /* Explicitly set to black to match other icons */
            opacity: 0.7;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        .card-complete-button svg {
            /* Match the styling of other button SVGs */
            width: 14px;
            height: 14px;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            stroke: #000; /* Explicitly set the stroke color to black */
        }
        
        .card:hover .card-complete-button {
            opacity: 1;
        }
        
        .card.completed .card-complete-button {
            background-color: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
            opacity: 1;
        }
        
        .card.completed .card-complete-button svg {
            stroke: #4CAF50; /* Ensure the SVG stroke is green when completed */
        }

        /* Knowledge Base Styles */
        .knowledge-base {
            max-width: 700px;
        }
        
        .kb-section {
            margin-bottom: 15px;
            border-radius: 8px;
            overflow: hidden;
            background-color: rgba(255, 255, 255, 0.03);
            transition: all 0.3s ease;
        }
        
        .kb-section details {
            width: 100%;
        }
        
        .kb-section summary {
            padding: 15px;
            font-weight: 600;
            cursor: pointer;
            position: relative;
            border-bottom: 1px solid transparent;
            transition: all 0.2s ease;
            user-select: none;
            color: var(--text-color); /* Use the text color variable to match the theme */
        }
        
        .kb-section summary:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .kb-section details[open] summary {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }
        
        .kb-section summary::after {
            content: "▼";
            position: absolute;
            right: 15px;
            font-size: 12px;
            color: var(--text-muted);
            transition: transform 0.3s ease;
        }
        
        .kb-section details[open] summary::after {
            transform: rotate(180deg);
        }
        
        .kb-content {
            padding: 0 15px 15px;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-muted);
        }
        
        .kb-content h4 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: var(--text-color); /* Use the text color variable to match the theme */
        }
        
        .kb-content h5 {
            margin: 15px 0 5px 0;
            font-size: 14px;
            color: var(--text-color); /* Use the text color variable to match the theme */
        }
        
        .kb-content p {
            margin: 0 0 10px 0;
        }
        
        .kb-content ul {
            margin: 0 0 15px 0;
            padding-left: 20px;
        }
        
        .kb-content li {
            margin-bottom: 5px;
        }
        
        .kb-content strong {
            color: var(--text-color);
            font-weight: 600;
        }
        
        /* Responsive Settings for smaller screens */
        @media (max-width: 768px) {
            .settings-content {
                width: 95%;
                height: 95vh;
                flex-direction: column;
            }
            
            .settings-sidebar {
                width: 100%;
                padding: 15px 10px;
                height: auto;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                flex-direction: row;
                justify-content: flex-start;
            }
            
            .settings-logo {
                padding: 15px;
            }
            
            .settings-nav {
                flex-direction: row;
                padding: 10px;
                overflow-x: auto;
                justify-content: flex-start;
            }
            
            .nav-item {
                flex-direction: column;
                padding: 10px;
                gap: 5px;
                width: 80px;
                text-align: center;
                font-size: 12px;
            }
            
            .nav-item.active::before {
                left: 0;
                top: auto;
                bottom: 0;
                height: 3px;
                width: 100%;
            }
            
            .settings-footer {
                display: flex;
                justify-content: center;
                margin-top: 20px;
            }
            
            .settings-main {
                padding: 20px 15px;
                position: relative;
            }
            
            .theme-options {
                flex-direction: column;
                align-items: center;
            }
            
            .theme-option {
                width: 100%;
                max-width: none;
                flex-direction: row;
                justify-content: flex-start;
            }
        }
        
        /* Calendar integration styles */
        .calendar-connect-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .connect-calendar-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: var(--text-color);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .connect-calendar-btn:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .connect-calendar-btn[data-provider="google"] {
            border-left: 4px solid #4285F4;
        }
        
        .connect-calendar-btn[data-provider="apple"] {
            border-left: 4px solid #A3AAAE;
        }
        
        .calendar-sync-options {
            margin-top: 15px;
            opacity: 0.7;
        }
        
        .connect-notice {
            font-size: 12px;
            color: var(--text-muted);
            font-style: italic;
            margin-top: 10px;
        }
        
        /* Calendar auth modal */
        .calendar-auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .calendar-auth-modal.active {
            opacity: 1;
            visibility: visible;
        }
        
        .calendar-auth-modal .modal-content {
            background-color: var(--bg-color);
            border-radius: 10px;
            padding: 25px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: translateY(20px);
            transition: all 0.3s ease;
        }
        
        .calendar-auth-modal.active .modal-content {
            transform: translateY(0);
        }
        
        .calendar-auth-modal h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }
        
        .calendar-auth-modal p {
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-color);
        }
        
        .calendar-auth-modal ul {
            margin-bottom: 20px;
            padding-left: 20px;
        }
        
        .calendar-auth-modal li {
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--text-muted);
        }
        
        .modal-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .modal-close-btn {
            padding: 8px 15px;
            background-color: var(--button-bg);
            border: none;
            border-radius: 5px;
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .modal-close-btn:hover {
            background-color: var(--button-hover);
        }
        
        /* Theme toggle styles */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.3s ease;
            border-radius: 50%;
            z-index: 10;
        }
        
        .theme-toggle:hover {
            color: var(--text-color);
            background-color: rgba(255, 255, 255, 0.05);
            transform: rotate(45deg);
        }
        
        .theme-toggle svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }
        
        /* Priority flags and due dates */
        .card-priority-flag {
            /* Cleaned up redundant properties that are now handled by card-header-controls button */
        }
        
        .card-priority-flag.card-priority-high {
            color: #e53935;
            background-color: rgba(229, 57, 53, 0.2);
        }
        
        .card-priority-flag.card-priority-medium {
            color: #fb8c00;
            background-color: rgba(251, 140, 0, 0.2);
        }
        
        .card-priority-flag.card-priority-low {
            color: #43a047;
            background-color: rgba(67, 160, 71, 0.2);
        }
        
        .card-due-date {
            /* Cleaned up redundant properties that are now handled by card-header-controls button */
        }
        
        /* Hover effect is already handled by the unified card-header-controls button styles */
        
        .due-date-display {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
            padding: 3px 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .due-date-display.overdue {
            background-color: rgba(229, 57, 53, 0.3);
            color: #ffcdd2;
        }
        
        .due-date-display.today {
            background-color: rgba(251, 140, 0, 0.3);
            color: #ffe0b2;
        }
        
        .due-date-display.upcoming {
            background-color: rgba(67, 160, 71, 0.3);
            color: #c8e6c9;
        }
        
        .date-picker-container {
            position: absolute;
            z-index: 1000;
            background-color: var(--bg-color);
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            padding: 12px;
            width: 240px; /* Reduced width */
            font-size: 0.9em; /* Smaller font size throughout */
        }
        
        .date-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }
        
        .date-picker-header h4 {
            margin: 0;
            font-size: 14px;
            color: var(--text-color);
        }
        
        .date-picker-close {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 3px 5px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 16px;
            line-height: 1;
        }
        
        .date-picker-close:hover {
            background-color: var(--hover-bg);
            color: var(--text-color);
        }
        
        .date-picker-calendar {
            margin-bottom: 10px;
        }
        
        .time-picker-container {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }
        
        .time-picker-header {
            font-size: 12px;
            color: var(--text-color);
            margin-bottom: 6px;
        }
        
        .time-picker-inputs {
            display: flex;
            gap: 5px;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .time-input {
            width: 40px; /* Smaller inputs */
            padding: 3px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--input-bg);
            color: var(--text-color);
            font-size: 12px;
            text-align: center;
        }
        
        .time-separator {
            color: var(--text-muted);
            font-weight: bold;
            font-size: 12px;
        }
        
        .time-period {
            padding: 3px 6px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--input-bg);
            color: var(--text-color);
            cursor: pointer;
            font-size: 12px;
        }
        
        .reminder-options {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
            display: flex; /* Make options horizontal */
            flex-wrap: wrap; /* Allow wrapping if needed */
            gap: 8px;
        }
        
        .reminder-option {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 0;
            cursor: pointer;
            flex-basis: 45%; /* Two options per row */
        }
        
        .reminder-option input[type="radio"] {
            margin: 0;
            transform: scale(0.8); /* Smaller radio buttons */
        }
        
        .reminder-option label {
            font-size: 12px;
            color: var(--text-color);
            cursor: pointer;
        }
        
        .date-picker-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border-color);
        }
        
        .date-picker-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .date-picker-btn.primary {
            background-color: var(--accent-color);
            color: white;
        }
        
        .date-picker-btn.primary:hover {
            background-color: var(--accent-hover);
        }
        
        .date-picker-btn.secondary {
            background-color: var(--button-bg);
            color: var(--text-color);
        }
        
        .date-picker-btn.secondary:hover {
            background-color: var(--button-hover);
        }
        
        .reminder-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            background-color: var(--accent-color);
            color: white;
            margin-left: 8px;
        }
        
        .reminder-badge svg {
            width: 12px;
            height: 12px;
        }

        /* Keyboard shortcut styles */
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 0 5px;
        }
        
        .calendar-header button {
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            padding: 3px 6px;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 12px;
        }
        
        .calendar-header button:hover {
            background-color: var(--hover-bg);
        }
        
        .calendar-header span {
            font-weight: 500;
            color: var(--text-color);
            font-size: 13px;
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            padding: 0 5px;
        }
        
        .calendar-day-header {
            text-align: center;
            font-size: 10px;
            color: var(--text-muted);
            padding: 3px 0;
            font-weight: 500;
        }
        
        .calendar-day {
            text-align: center;
            padding: 5px 2px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 11px;
            color: var(--text-color);
        }
        
        .calendar-day:hover {
            background-color: var(--hover-bg);
        }
        
        .calendar-day.padding {
            cursor: default;
        }
        
        .calendar-day.today {
            background-color: var(--accent-color);
            color: white;
            font-weight: 500;
        }
        
        .calendar-day.selected {
            background-color: var(--accent-hover);
            color: white;
            font-weight: 500;
        }
        
        /* Change text color to white for all elements inside cards */
        .card {
            color: white;
        }
        
        /* Ensure specific elements inside cards also have white text */
        .card h1, .card h2, .card h3, .card h4, .card h5, .card h6,
        .card p, .card span, .card div, .card label,
        .card .card-title, .card .card-description, .card .card-date,
        .card-content, .task-title, .task-description {
            color: white !important;
        }
        
        /* Make icon containers white */
        .icon-container, .card-icons, .task-icons, .icons,
        .card-footer, .card-actions, .card-options {
            color: white !important;
        }
        
        /* Ensure individual icons are white */
        .icon, .fa, .fas, .far, .fab, .material-icons {
            color: white !important;
        }
        
        /* Make icon container backgrounds white */
        .card-complete-button,
        .card-calendar-button,
        .card-flag-button,
        .card-delete-button,
        .card-collapse-button,
        .card-options-button,
        .card-action-button,
        .card .icon-button {
            background-color: white !important;
            color: #333 !important; /* Darker text for contrast against white */
        }
        
        /* Update the SVG styling for all icon buttons */
        .card-complete-button svg,
        .card-calendar-button svg,
        .card-flag-button svg,
        .card-delete-button svg,
        .card-collapse-button svg,
        .card-options-button svg,
        .card-action-button svg,
        .card .icon-button svg {
            stroke: #333 !important; /* Darker stroke for contrast against white */
        }
        
        /* Update the specific styling for card-complete-button */
        .card-complete-button {
            background-color: white !important;
            color: #333 !important;
        }
        
        .card-complete-button svg {
            stroke: #333 !important;
        }
        
        /* For completed cards, maintain the green confirmation styling */
        .card.completed .card-complete-button {
            background-color: white !important;
            color: #4CAF50 !important;
        }
        
        .card.completed .card-complete-button svg {
            stroke: #4CAF50 !important;
        }

        /* Super specific selectors for all icon buttons in cards */
        .card *[class*="button"],
        .card *[class*="icon"],
        .card .action-icon,
        .card .action-button,
        .card-action-icon,
        .card-action-button,
        .card-complete-button,
        .card-edit-button,
        .card-delete-button,
        .card-flag-button,
        .card-calendar-button,
        .card-collapse-button,
        .card-pin-button,
        .card-archive-button,
        .card-more-button,
        .card .task-action,
        .card .task-button,
        .card .action-item,
        .card .card-action,
        .card button:not(.date-picker-btn):not(.color-option),
        .card-footer button,
        .card-header button {
            background-color: white !important;
            color: #333 !important;
            border: none !important;
            opacity: 1 !important;
        }
        
        /* All SVGs and icons inside these buttons */
        .card *[class*="button"] svg,
        .card *[class*="icon"] svg,
        .card button:not(.date-picker-btn):not(.color-option) svg,
        .card-footer button svg,
        .card-header button svg,
        .card i, .card svg {
            stroke: #333 !important;
            fill: none !important;
            color: #333 !important;
        }
        
        /* Special handling for completed button when active */
        .card.completed .card-complete-button {
            background-color: white !important;
            color: #4CAF50 !important;
        }
        
        .card.completed .card-complete-button svg,
        .card.completed .card-complete-button i {
            stroke: #4CAF50 !important;
            color: #4CAF50 !important;
        }
        
        /* Override any hover effects */
        .card *[class*="button"]:hover,
        .card button:not(.date-picker-btn):not(.color-option):hover {
            background-color: white !important;
        }
        
        /* Microphone listening animation */
        @keyframes micPulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .mic-button.listening {
            animation: micPulse 1.5s infinite ease-in-out;
            color: white !important;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }
        
        .mic-button.listening .mic-icon {
            fill: white;
        }
        
        .date-picker-btn.secondary:hover {
            background-color: var(--button-hover);
        }
        
        .reminder-selector {
            margin-top: 10px;
            margin-bottom: 15px;
        }
        
        .reminder-dropdown {
            padding: 6px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--input-bg);
            color: var(--text-color);
            cursor: pointer;
            font-size: 12px;
            width: 100%;
            max-width: 200px;
        }
    </style>
</head>
<body class="dark-mode">
    <!-- Settings icon in top right corner -->
    <button class="settings-button">
        <svg class="settings-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
    </button>

    <!-- Settings Modal -->
    <div class="settings-modal">
        <div class="settings-content">
            <!-- Close X button -->
            <button class="settings-close-x" id="settings-close-x">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
            <!-- Two-column layout -->
            <div class="settings-sidebar">
                <div class="settings-logo">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M12 16V12"></path>
                        <path d="M12 8h.01"></path>
                    </svg>
                    <span>Settings</span>
                </div>
                <nav class="settings-nav">
                    <button class="nav-item active" data-target="appearance">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                        <span>Appearance</span>
                    </button>
                    <button class="nav-item" data-target="data">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                            <polyline points="10 9 9 9 8 9"></polyline>
                        </svg>
                        <span>Data Management</span>
                    </button>
                    <button class="nav-item" data-target="cards">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="3" y1="9" x2="21" y2="9"></line>
                            <line x1="9" y1="21" x2="9" y2="9"></line>
                        </svg>
                        <span>Cards</span>
                    </button>
                    <button class="nav-item" data-target="about">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                        <span>About</span>
                    </button>
                </nav>
                <div class="settings-footer">
                    <!-- Close button removed -->
                </div>
            </div>
            
            <div class="settings-main">
                <div class="settings-panel active" id="appearance-panel">
                    <h2>Appearance</h2>
                    <div class="setting-group">
                        <h3>Theme</h3>
                        <p class="setting-description">Choose between dark and light mode for the application.</p>
                        <div class="theme-options">
                            <button id="dark-mode-btn" class="theme-option active">
                                <div class="option-preview dark">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                                    </svg>
                                </div>
                                <span>Dark Mode</span>
                            </button>
                            <button id="light-mode-btn" class="theme-option">
                                <div class="option-preview light">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <circle cx="12" cy="12" r="5"></circle>
                                        <line x1="12" y1="1" x2="12" y2="3"></line>
                                        <line x1="12" y1="21" x2="12" y2="23"></line>
                                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                                        <line x1="1" y1="12" x2="3" y2="12"></line>
                                        <line x1="21" y1="12" x2="23" y2="12"></line>
                                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                                    </svg>
                                </div>
                                <span>Light Mode</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <h3>Card Display</h3>
                        <p class="setting-description">Choose how cards appear when first created.</p>
                        <div class="checkbox-container">
                            <input type="checkbox" id="collapse-new-cards" class="settings-checkbox">
                            <label for="collapse-new-cards">Collapse new cards by default</label>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <h3>Confirmation Dialogs</h3>
                        <p class="setting-description">Control when confirmation dialogs appear.</p>
                        <div class="checkbox-container">
                            <input type="checkbox" id="confirm-delete-cards" class="settings-checkbox" checked>
                            <label for="confirm-delete-cards">Confirm before deleting cards</label>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <h3>Font Size</h3>
                        <p class="setting-description">Adjust the text size throughout the application.</p>
                        <div class="slider-container">
                            <span class="slider-label">A</span>
                            <input type="range" min="80" max="120" value="100" class="slider" id="font-size-slider">
                            <span class="slider-label">A</span>
                        </div>
                        <div class="slider-value">100%</div>
                    </div>
                </div>
                
                <div class="settings-panel" id="data-panel">
                    <h2>Data Management</h2>
                    <div class="setting-group">
                        <h3>Export & Import</h3>
                        <p class="setting-description">Backup your cards data or restore from a previous backup.</p>
                        <div class="button-row">
                            <button class="setting-button" id="export-data">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="7 10 12 15 17 10"></polyline>
                                    <line x1="12" y1="15" x2="12" y2="3"></line>
                                </svg>
                                Export All Data
                            </button>
                            <button class="setting-button" id="import-data">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="17 8 12 3 7 8"></polyline>
                                    <line x1="12" y1="3" x2="12" y2="15"></line>
                                </svg>
                                Import Data
                            </button>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <h3>Clear Data</h3>
                        <p class="setting-description">Remove all saved cards and settings. This action cannot be undone.</p>
                        <button class="setting-button warning" id="clear-data">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                <line x1="10" y1="11" x2="10" y2="17"></line>
                                <line x1="14" y1="11" x2="14" y2="17"></line>
                            </svg>
                            Clear All Data
                        </button>
                    </div>
                </div>
                
                <div class="settings-panel" id="cards-panel">
                    <h2>Cards</h2>
                    <div class="setting-group">
                        <h3>Stack Size</h3>
                        <p class="setting-description">Set the maximum number of cards visible in the stack.</p>
                        <div class="select-container">
                            <select id="max-cards-setting" class="settings-select">
                                <option value="5">5 cards</option>
                                <option value="10" selected>10 cards</option>
                                <option value="15">15 cards</option>
                                <option value="20">20 cards</option>
                                <option value="50">50 cards</option>
                                <option value="100">100 cards</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <h3>Card Appearance</h3>
                        <p class="setting-description">Customize how your cards look.</p>
                        <div class="checkbox-container">
                            <input type="checkbox" id="show-timestamps" class="settings-checkbox" checked>
                            <label for="show-timestamps">Show timestamps on cards</label>
                        </div>
                        <div class="checkbox-container">
                            <input type="checkbox" id="show-categories" class="settings-checkbox" checked>
                            <label for="show-categories">Show categories on cards</label>
                        </div>
                        <div class="checkbox-container">
                            <input type="checkbox" id="show-completed-cards" class="settings-checkbox" checked>
                            <label for="show-completed-cards">Show completed cards section</label>
                        </div>
                    </div>
                    
                    <div class="setting-group">
                        <h3>Calendar Integration</h3>
                        <p class="setting-description">Connect with calendar services to sync your reminders and events.</p>
                        <div class="calendar-connect-options">
                            <button class="connect-calendar-btn" data-provider="google">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="16" y1="2" x2="16" y2="6"></line>
                                    <line x1="8" y1="2" x2="8" y2="6"></line>
                                    <line x1="3" y1="10" x2="21" y2="10"></line>
                                </svg>
                                Connect Google Calendar
                            </button>
                            <button class="connect-calendar-btn" data-provider="apple">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="16" y1="2" x2="16" y2="6"></line>
                                    <line x1="8" y1="2" x2="8" y2="6"></line>
                                    <line x1="3" y1="10" x2="21" y2="10"></line>
                                </svg>
                                Connect Apple Calendar
                            </button>
                        </div>
                        <div class="calendar-sync-options">
                            <div class="checkbox-container">
                                <input type="checkbox" id="sync-reminders" class="settings-checkbox" checked disabled>
                                <label for="sync-reminders">Sync reminder cards to calendar</label>
                            </div>
                            <div class="checkbox-container">
                                <input type="checkbox" id="import-events" class="settings-checkbox" disabled>
                                <label for="import-events">Import calendar events as cards</label>
                            </div>
                            <p class="connect-notice">Connect a calendar service to enable these options</p>
                        </div>
                    </div>
                </div>
                
                <div class="settings-panel" id="about-panel">
                    <h2>About</h2>
                    <div class="setting-group">
                        <div class="about-app">
                            <div class="app-logo">
                                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="3" y1="9" x2="21" y2="9"></line>
                                    <line x1="9" y1="21" x2="9" y2="9"></line>
                                </svg>
                            </div>
                            <h3>Task Cards</h3>
                            <p class="version">Version 1.0.0</p>
                            <p class="about-description">A simple and elegant way to organize your tasks and thoughts. Task Cards uses intelligent text analysis to automatically categorize your entries, saving you time and mental effort while keeping everything neatly organized.</p>
                        </div>
                        
                        <div class="setting-group knowledge-base">
                            <h3>Knowledge Base</h3>
                            
                            <div class="kb-section">
                                <details>
                                    <summary>Getting Started</summary>
                                    <div class="kb-content">
                                        <h4>Welcome to Task Cards</h4>
                                        <p>Task Cards helps you organize your thoughts, tasks, ideas, and more using a flexible card-based system. Each card is automatically categorized based on what you type, making organization effortless.</p>
                                        
                                        <h5>Creating Your First Card</h5>
                                        <p>To create a card, simply type in the input bar at the bottom of the screen and press Enter. The app will automatically detect what type of content you're creating and categorize it appropriately.</p>
                                        
                                        <h5>Card Types</h5>
                                        <ul>
                                            <li><strong>Task:</strong> For actionable to-do items</li>
                                            <li><strong>Note:</strong> For general information and longer text</li>
                                            <li><strong>Idea:</strong> For creative thoughts and concepts</li>
                                            <li><strong>Reminder:</strong> For time-sensitive alerts</li>
                                            <li><strong>Meeting:</strong> For appointments and gatherings</li>
                                            <li><strong>Goal:</strong> For targets and objectives</li>
                                            <li><strong>Work:</strong> For job-related items</li>
                                            <li><strong>Travel:</strong> For journey/trip planning</li>
                                        </ul>
                                    </div>
                                </details>
                            </div>
                            
                            <div class="kb-section">
                                <details>
                                    <summary>Working with Cards</summary>
                                    <div class="kb-content">
                                        <h4>Card Interactions</h4>
                                        
                                        <h5>Moving Cards</h5>
                                        <p>Click and drag a card to position it anywhere on your screen. Double-click a card to return it to the stack.</p>
                                        
                                        <h5>Editing Cards</h5>
                                        <p>Click on the card title to edit it. For task cards, you can add steps by clicking the "Add step" button at the bottom of the card.</p>
                                        
                                        <h5>Card Controls</h5>
                                        <ul>
                                            <li><strong>Complete ✓:</strong> Mark a card as completed. Completed cards move to the completed section.</li>
                                            <li><strong>Collapse ▲:</strong> Collapse or expand a card to save space.</li>
                                            <li><strong>Delete ×:</strong> Remove a card permanently.</li>
                                        </ul>
                                        
                                        <h5>Changing Card Colors</h5>
                                        <p>Click the color dot in the bottom-left corner of a card to cycle through different color options.</p>
                                        
                                        <h5>Completing Cards</h5>
                                        <p>Click the checkmark icon in the card header to mark it as complete. Completed cards are moved to the completed cards section in the bottom-right corner of the screen. Click the same icon on a completed card to reopen it.</p>
                                    </div>
                                </details>
                            </div>
                            
                            <div class="kb-section">
                                <details>
                                    <summary>Completed Cards Section</summary>
                                    <div class="kb-content">
                                        <h4>Managing Completed Cards</h4>
                                        
                                        <h5>Completed Cards Container</h5>
                                        <p>When you mark cards as completed, they are moved to a dedicated "Completed Cards" section that appears in your workspace. This helps keep your active cards separate from completed ones.</p>
                                        
                                        <h5>Moving the Completed Section</h5>
                                        <p>The completed cards section is draggable! You can position it anywhere on your screen by clicking and dragging the section header or the dot grip handle. The position is saved and will be remembered between sessions.</p>
                                        
                                        <h5>Collapsing the Section</h5>
                                        <p>Click the collapse arrow in the completed cards section header to minimize the section while keeping the header visible. Click again to expand it.</p>
                                        
                                        <h5>Showing/Hiding the Section</h5>
                                        <p>You can completely hide the completed cards section through the Cards settings panel by unchecking "Show completed cards section". When hidden, completed cards are still stored but not displayed until you enable the setting again.</p>
                                        
                                        <h5>Reopening Completed Cards</h5>
                                        <p>To move a card back to the active workspace, click the checkmark icon on any completed card to reopen it. The card will return to the main stack.</p>
                                    </div>
                                </details>
                            </div>
                            
                            <div class="kb-section">
                                <details>
                                    <summary>Specialized Card Types</summary>
                                    <div class="kb-content">
                                        <h4>Card Type Features</h4>
                                        
                                        <h5>Task Cards</h5>
                                        <p>Task cards allow you to create checklists with multiple steps. Check off steps as you complete them.</p>
                                        
                                        <h5>Note Cards</h5>
                                        <p>Note cards provide a larger text area for longer content, perfect for storing information.</p>
                                        
                                        <h5>Reminder Cards</h5>
                                        <p>Reminders automatically extract dates and times from your text and highlight them. You can also manually add dates.</p>
                                        
                                        <h5>Idea Cards</h5>
                                        <p>Idea cards are designed for brainstorming with a focus on capturing creative thoughts.</p>
                                        
                                        <h5>Meeting Cards</h5>
                                        <p>Meeting cards help organize agenda items and meeting notes with bullet points.</p>
                                        
                                        <h5>Goal Cards</h5>
                                        <p>Goal cards are structured for tracking progress toward objectives with milestones.</p>
                                    </div>
                                </details>
                            </div>
                            
                            <div class="kb-section">
                                <details>
                                    <summary>Smart Features</summary>
                                    <div class="kb-content">
                                        <h4>Intelligent Card Creation</h4>
                                        <p>Task Cards uses natural language processing to automatically categorize your content:</p>
                                        
                                        <h5>Category Detection</h5>
                                        <p>As you type, the app analyzes your text and predicts what type of card it should be. You'll see the detected category appear in the input bar.</p>
                                        
                                        <h5>How Text Type Classification Works</h5>
                                        <p>Our intelligent text type identifier uses a multi-layered approach to determine the most appropriate category for your input:</p>
                                        
                                        <ul>
                                            <li><strong>Pattern Recognition:</strong> The system identifies specific text patterns like questions, bullet points, date formats, and more</li>
                                            <li><strong>Keyword Analysis:</strong> Each category has associated keywords and phrases that indicate its relevance</li>
                                            <li><strong>Context Evaluation:</strong> Beyond individual words, the system analyzes how words are used together</li>
                                            <li><strong>Sentence Structure:</strong> Grammatical patterns help determine if text is a command (Task), observation (Note), or aspiration (Goal)</li>
                                            <li><strong>Scoring System:</strong> Multiple factors are weighted together to determine the final category</li>
                                        </ul>
                                        
                                        <h5>Category Identifiers</h5>
                                        <p>The system recognizes these patterns for different categories:</p>
                                        
                                        <ul>
                                            <li><strong>Task:</strong> Action verbs, short phrases, imperatives, shopping terms, to-do formats</li>
                                            <li><strong>Work:</strong> Project terminology, business context, colleague references, deliverables</li>
                                            <li><strong>Travel:</strong> Destination references, transportation terms, accommodation words</li>
                                            <li><strong>Meeting:</strong> Meeting formats, attendee references, discussion terms</li>
                                            <li><strong>Reminder:</strong> Time/date references, deadline terminology, alert language</li>
                                            <li><strong>Idea:</strong> Questions, creative concepts, possibilities, considerations</li>
                                            <li><strong>Goal:</strong> Achievement language, future commitments, improvement terms</li>
                                            <li><strong>Note:</strong> Information capturing, longer text, documentation language</li>
                                        </ul>
                                        
                                        <p>For developers: You can enable detailed categorization analysis in the Developer settings panel to see how the system scores different category options for any input text.</p>
                                        
                                        <h5>Date & Time Recognition</h5>
                                        <p>When you include dates or times (like "tomorrow at 3pm"), the app will recognize these and format them appropriately for Reminder cards.</p>
                                        
                                        <h5>Question Detection</h5>
                                        <p>Text that ends with a question mark is typically categorized as an Idea, perfect for capturing questions you want to explore later.</p>
                                    </div>
                                </details>
                            </div>
                            
                            <div class="kb-section">
                                <details>
                                    <summary>Tips & Tricks</summary>
                                    <div class="kb-content">
                                        <h4>Power User Tips</h4>
                                        
                                        <h5>Keyboard Shortcuts</h5>
                                        <ul>
                                            <li><strong>Enter</strong> while typing: Create a new card</li>
                                            <li><strong>Escape</strong>: Close the settings modal</li>
                                            <li><strong>Double-click</strong> on a card: Return it to the stack</li>
                                        </ul>
                                        
                                        <h5>Organizing Your Workspace</h5>
                                        <p>Group related cards together by dragging them to similar areas of the screen. This creates visual "zones" for different projects or topics.</p>
                                        
                                        <h5>Completed Cards Management</h5>
                                        <p>For a cleaner workspace, use the draggable completed cards section to move completed items off to one side. If you're focusing on what's left to do, you can hide the completed section entirely from the Cards settings.</p>
                                        
                                        <h5>Card Format Tricks</h5>
                                        <ul>
                                            <li>Start with a bullet point to automatically create a Task card</li>
                                            <li>End with a question mark to create an Idea card</li>
                                            <li>Include dates/times to create a Reminder card</li>
                                            <li>Begin with "I want to..." to create a Goal card</li>
                                        </ul>
                                        
                                        <h5>Data Management</h5>
                                        <p>Regularly export your data (in the Data Management tab) to back up your cards. You can import this data on any device to keep your cards synchronized.</p>
                                    </div>
                                </details>
                            </div>
                            
                            <div class="kb-section">
                                <details>
                                    <summary>Customization</summary>
                                    <div class="kb-content">
                                        <h4>Personalizing Your Experience</h4>
                                        
                                        <h5>Theme Settings</h5>
                                        <p>Switch between Dark and Light mode in the Appearance tab to match your preference or lighting conditions.</p>
                                        
                                        <h5>Font Size</h5>
                                        <p>Adjust the font size slider to make text larger or smaller based on your comfort level and screen size.</p>
                                        
                                        <h5>Card Stack Size</h5>
                                        <p>Configure how many cards are visible in the stack at once in the Cards tab. This helps manage performance with larger collections.</p>
                                        
                                        <h5>Card Visibility Options</h5>
                                        <p>In the Cards settings panel, you can control several visibility options:</p>
                                        <ul>
                                            <li><strong>Show timestamps on cards:</strong> Toggle the visibility of the timestamp on each card</li>
                                            <li><strong>Show categories on cards:</strong> Toggle the visibility of the category tag on each card</li>
                                            <li><strong>Show completed cards section:</strong> Toggle the visibility of the entire completed cards section</li>
                                        </ul>
                                        
                                        <h5>Workspace Layout</h5>
                                        <p>Customize your workspace by dragging cards and the completed cards section to your preferred locations. All positions are saved between sessions.</p>
                                    </div>
                                </details>
                            </div>
                            
                            <div class="kb-section">
                                <details>
                                    <summary>Recent Updates & Features</summary>
                                    <div class="kb-content">
                                        <h4>Latest Improvements</h4>
                                        
                                        <h5>Card Styling Enhancements</h5>
                                        <p>We've made several visual improvements to enhance the dark theme experience:</p>
                                        <ul>
                                            <li><strong>White Text:</strong> Changed all text within cards to white for better visibility in dark mode</li>
                                            <li><strong>Dark Card Colors:</strong> Cards now use elegant shades of black by default, while maintaining color picker functionality</li>
                                            <li><strong>Icon Styling:</strong> Action buttons on cards have white backgrounds with dark icons for improved contrast</li>
                                        </ul>
                                        
                                        <h5>Core Features Overview</h5>
                                        <p>The application includes these powerful features:</p>
                                        <ul>
                                            <li><strong>Card Actions:</strong> Complete, flag for priority, add due dates, delete, and collapse cards</li>
                                            <li><strong>Time Management:</strong> Set reminders with 15-min, 30-min, and 1-hour advance options</li>
                                            <li><strong>Card Organization:</strong> Smart categorization of tasks with customizable display options</li>
                                            <li><strong>Theme Support:</strong> Full dark/light mode with personalized styling</li>
                                        </ul>
                                        
                                        <h5>Technical Improvements</h5>
                                        <ul>
                                            <li><strong>Color Palette:</strong> Expanded shades of black for cards while preserving color picker feature</li>
                                            <li><strong>Contrast Enhancement:</strong> Improved text and button visibility for better accessibility</li>
                                            <li><strong>Completed Task Styling:</strong> Special handling for completed tasks with intuitive visual cues</li>
                                        </ul>
                                    </div>
                                </details>
                            </div>
                        </div>
                        
                        <div class="setting-group">
                            <div class="credits">
                                <p>Created with ❤️</p>
                                <p class="copyright">© 2023 Task Cards</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Cards Container -->
    <div class="cards-container">
        <div class="cards-stack">
            <!-- Cards will be dynamically added here -->
        </div>
    </div>
    
    <!-- Completed Cards Section -->
    <div class="completed-cards-section">
        <div class="completed-section-header">
            <div class="drag-handle">
                <svg width="10" height="16" viewBox="0 0 10 16" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="2" cy="2" r="1" fill="currentColor" stroke="none"/>
                    <circle cx="8" cy="2" r="1" fill="currentColor" stroke="none"/>
                    <circle cx="2" cy="8" r="1" fill="currentColor" stroke="none"/>
                    <circle cx="8" cy="8" r="1" fill="currentColor" stroke="none"/>
                    <circle cx="2" cy="14" r="1" fill="currentColor" stroke="none"/>
                    <circle cx="8" cy="14" r="1" fill="currentColor" stroke="none"/>
                </svg>
            </div>
            <div class="completed-section-title">Completed Cards</div>
            <div class="completed-cards-count">0</div>
            <button class="collapse-completed-section">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
            </button>
        </div>
        <div class="completed-cards-container">
            <!-- Completed cards will be moved here -->
        </div>
    </div>

    <!-- Notification popup -->
    <div class="notification">
        <svg class="notification-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v6h-2zm0 8h2v2h-2z"/>
        </svg>
        <span class="notification-message">You've reached the maximum card limit of 50!</span>
    </div>

    <!-- Pill-shaped input bar -->
    <div class="pill-bar">
        <span class="inline-category"></span>
        <input type="text" class="task-input" placeholder="What are you getting done today?" autofocus>
        <button class="mic-button">
            <svg class="mic-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
            </svg>
        </button>
    </div>

    <script>
        // Set up initial variables
        const STORAGE_KEY = 'task_cards_data';
        
        // Speech recognition variables
        let isListening = false;
        let recognitionInstance = null;
        
        const cardColors = [
            // Dark colors (default) - good contrast for white text
            '#333333', // Dark grey
            '#1F2937', // Dark blue-grey
            '#312E81', // Dark indigo
            '#4C1D95', // Dark purple
            '#831843', // Dark pink
            '#7F1D1D', // Dark red
            '#14532D', // Dark green
            '#1E3A8A', // Dark blue
            // Vibrant colors
            'linear-gradient(135deg, #6A11CB 0%, #2575FC 100%)', // Purple to blue
            'linear-gradient(135deg, #FF6CAB 0%, #7366FF 100%)', // Pink to purple
            'linear-gradient(135deg, #08AEEA 0%, #2AF598 100%)', // Blue to green
            'linear-gradient(135deg, #FEE140 0%, #FA709A 100%)', // Yellow to pink
            'linear-gradient(135deg, #43CBFF 0%, #9708CC 100%)', // Blue to purple
            'linear-gradient(135deg, #667EEA 0%, #764BA2 100%)', // Blue to purple
            'linear-gradient(135deg, #F83600 0%, #F9D423 100%)', // Red to yellow
            'linear-gradient(135deg, #3B2667 0%, #BC78EC 100%)', // Purple to light purple
            // Solid vibrant colors
            '#3B82F6', // Bright blue
            '#8B5CF6', // Bright purple
            '#EC4899', // Bright pink
            '#EF4444', // Bright red
            '#F59E0B', // Bright orange
            '#10B981', // Bright green
            '#06B6D4', // Bright cyan
            '#6366F1'  // Bright indigo
        ];
        const categories = ['Task', 'Work', 'Travel', 'Meeting', 'Reminder', 'Idea', 'Goal', 'Note'];

        // Default gray color
        const defaultColor = '#333333';
        const defaultShadow = '0 2px 10px rgba(0, 0, 0, 0.5)';
        
        // Utility function to determine if text should be dark or light based on background
        function getTextColorForBackground(backgroundColor) {
            // For gradients, default to white text
            if (backgroundColor.includes('gradient')) {
                return 'white';
            }
            
            // For hex colors, calculate brightness
            let color = backgroundColor.trim();
            
            // Convert shorthand hex (#fff) to full hex (#ffffff)
            if (color.startsWith('#') && color.length === 4) {
                color = '#' + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
            }
            
            // Extract RGB values
            let r, g, b;
            if (color.startsWith('#')) {
                r = parseInt(color.substr(1, 2), 16);
                g = parseInt(color.substr(3, 2), 16);
                b = parseInt(color.substr(5, 2), 16);
            } else {
                return 'white'; // Default for unknown formats
            }
            
            // Calculate perceived brightness using the formula: (0.299*R + 0.587*G + 0.114*B)
            const brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            
            // Use white text for dark backgrounds, black text for light backgrounds
            return brightness > 0.5 ? 'black' : 'white';
        }
        
        let currentColorIndex = 0;
        let typingTimer; // Timer to track typing pauses
        const typingTimeout = 1500; // Reset to gray after 1.5 seconds of no typing
        let cardCount = 0; // Track number of cards
        const maxVisibleCards = window.maxVisibleCards || 100; // Maximum number of cards visible in stack
        
        const pillBar = document.querySelector('.pill-bar');
        const taskInput = document.querySelector('.task-input');
        const micButton = document.querySelector('.mic-button');
        const settingsButton = document.querySelector('.settings-button');
        const cardsStack = document.querySelector('.cards-stack');
        
        // Category patterns for intelligent labeling
        const categoryPatterns = {
            'Task': [
                /\btodo\b/i, 
                /\btask(s)?\b/i,
                /\bcomplete\b/i, 
                /\bfinish(ed)?\b/i,
                /\bdo\b/i, 
                /need(s)? to\b/i,
                /\bhave\s+to\b/i,
                /\bgotta\b/i,
                /\bmust\b/i,
                /\bshould\b/i,
                /\bissue\b/i,
                /\bfix\b/i,
                /\bsolve\b/i,
                /\bhandle\b/i,
                /\baction\s+item(s)?\b/i,
                /\bassignment\b/i,
                /\bduty\b/i,
                /\bresponsibility\b/i,
                /\bpriority\b/i,
                /\bpending\b/i,
                /\b(can|could) you\b/i,
                /\blet's\b.*?\b(do|make|create|build|implement)\b/i,
                /\bdon't forget to\b/i,
                /^(please\s+)?(make|create|build|implement|do)/i,
                /\b(add|remove|change|update|modify)\b/i
            ],
            'Work': [
                /\bwork\b/i,
                /\bjob\b/i, 
                /\bproject\b/i, 
                /\bclient\b/i, 
                /\bdeadline\b/i, 
                /\bdeliverable(s)?\b/i, 
                /\breport(s)?\b/i, 
                /\bpresentation(s)?\b/i,
                /\bwork on\b/i,
                /\bcode\b/i,
                /\bprogram\b/i,
                /\bdevelop(ment)?\b/i,
                /\breview\b/i,
                /\bdocument(ation)?\b/i,
                /\bemail\b/i,
                /\bcall with\b/i,
                /\bemployee\b/i,
                /\bmanager\b/i,
                /\bcoworker\b/i,
                /\bcolleague\b/i,
                /\bboss\b/i,
                /\bhiring\b/i,
                /\binterview\b/i,
                /\bresume\b/i,
                /\bcv\b/i,
                /\bq[1-4]\b/i,
                /\bquarter\b/i,
                /\bfiscal\b/i,
                /\bbudget\b/i,
                /\bexpense(s)?\b/i,
                /\binvoice\b/i,
                /\bpayment\b/i,
                /\bsalary\b/i,
                /\b(weekly|monthly|quarterly|annual) report\b/i,
                /\boffice\b/i,
                /\bdepartment\b/i,
                /\bhr\b/i,
                /\bit\b/i
            ],
            'Travel': [
                /\btravel\b/i, 
                /\btrip\b/i, 
                /\bvacation\b/i,
                /\bholiday\b/i,
                /\bvisit\b/i, 
                /\btour\b/i,
                /\bflight\b/i,
                /\bplane\b/i,
                /\btrain\b/i,
                /\bbus\b/i, 
                /\bhotel\b/i,
                /\blodging\b/i,
                /\baccommodation\b/i,
                /\bairbnb\b/i,
                /\bpacking\b/i,
                /\bsuitcase\b/i,
                /\bluggage\b/i, 
                /\bdrive\b/i,
                /\broad trip\b/i,
                /\bitinerary\b/i,
                /\breservation\b/i,
                /\bbook(ing)?\b.*?\b(ticket|flight|hotel|reservation|accommodation)\b/i,
                /\brent\s+a\s+car\b/i,
                /\bcar\s+rental\b/i,
                /\bpassport\b/i,
                /\bvisa\b/i,
                /\binternational\b/i,
                /\bcurrency\b/i,
                /\bexchange\s+rate\b/i,
                /\btraveler'?s\s+check\b/i,
                /\btourism\b/i,
                /\bsightseeing\b/i,
                /\btour guide\b/i,
                /\bcruise\b/i,
                /\bresort\b/i,
                /\bdestination\b/i,
                /\bterminal\b/i,
                /\bgate\b/i,
                /\bboard(ing)?\b/i,
                /\bairport\b/i,
                /\btake off\b/i,
                /\bland(ing)?\b/i,
                /going\s+to\s+([A-Z][a-z]+)/
            ],
            'Meeting': [
                /\bmeeting\b/i, 
                /\bcall\b/i, 
                /\bconference\b/i,
                /\bconversation\b/i,
                /\bdiscuss(ion)?\b/i, 
                /\bsession\b/i,
                /\binterview\b/i, 
                /\bappointment\b/i,
                /\bconsultation\b/i,
                /\bzoom\b/i,
                /\bmicrosoft teams\b/i,
                /\bms teams\b/i,
                /\bteams\b/i,
                /\bwebex\b/i,
                /\bgoogle meet\b/i,
                /\bgoogle hangouts\b/i,
                /\bhangouts\b/i,
                /\bmeet with\b/i,
                /\bmeet up\b/i,
                /\bretro(spective)?\b/i,
                /\b1:1\b/i,
                /\b1-1\b/i,
                /\bone-on-one\b/i,
                /\b1-on-1\b/i,
                /\bsync\b/i,
                /\bstand(up|down)\b/i,
                /\btownhall\b/i,
                /\ball-hands\b/i,
                /\bresync\b/i,
                /\bchat with\b/i,
                /\bscrum\b/i,
                /\bsprint\b/i,
                /\bplan(ning)?\b/i,
                /\bdemo\b/i,
                /\bagenda\b/i,
                /\bbriefing\b/i,
                /\bbrain(storming|storm)\b/i,
                /\bcheck-in\b/i,
                /\bkickoff\b/i,
                /\bworkshop\b/i,
                /\bseminar\b/i,
                /\bgathering\b/i,
                /\bassembly\b/i,
                /\b(video|audio)\s+call\b/i,
                /meet\s+with\s+([A-Z][a-z]+)/,
                /talk\s+to\s+([A-Z][a-z]+)/,
                /\bat\s+\d{1,2}(:\d{2})?\s*(am|pm|AM|PM)?/
            ],
            'Reminder': [
                /\bremember\b/i, 
                /\bremind(er)?\b/i, 
                /\bdon'?t\s+forget\b/i, 
                /\bdate\b/i, 
                /\banniversary\b/i, 
                /\bbirthday\b/i,
                /\bimportant\b/i,
                /\balert\b/i,
                /\balarm\b/i,
                /\bnotice\b/i,
                /\bnotification\b/i,
                /\bremembrance\b/i,
                /\bmemo\b/i,
                /\bevent\b/i,
                /\bceremony\b/i,
                /\bcelebration\b/i,
                /\bparty\b/i,
                /\bappointment\b/i,
                /\bdeadline\b/i,
                /\bdue\s+date\b/i,
                /\bat\s+\d{1,2}(:\d{2})?\s*(am|pm|AM|PM)/i,
                /\b\d{1,2}(:\d{2})?\s*(am|pm|AM|PM)\b/i,
                /\b(in|after)\s+\d+\s+(minute|hour|day|week|month|year)s?\b/i,
                /\b(tomorrow|today|tonight|next (week|month|year))\b/i,
                /\bin\s+\d+\s+(days|weeks|months|years)\b/i,
                /\bon\s+(mon|tues|wednes|thurs|fri|satur|sun)(day)?\b/i,
                /\bnext\s+(mon|tues|wednes|thurs|fri|satur|sun)(day)?\b/i,
                /\blast\s+(mon|tues|wednes|thurs|fri|satur|sun)(day)?\b/i,
                /\bon\s+(january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{1,2}(st|nd|rd|th)?\b/i,
                /\bnote\s+to\s+self\b/i,
                /\bset\s+a\s+reminder\b/i,
                /\bupcoming\b/i,
                /\b(day|week|month) after\b/i,
                /\b(day|week|month) before\b/i,
                /\boops\b/i,
                /\walmost\s+forgot\b/i,
                /\brevisit\b/i,
                /\bget\s+back\s+to\b/i,
                /\bfollow\s+up\b/i,
                /\bcheck\s+(on|in)\b/i,
                /(\d{1,2})\/(\d{1,2})(\/\d{2,4})?/
            ],
            'Idea': [
                /\bidea\b/i, 
                /\bthought\b/i, 
                /\bcreative\b/i, 
                /\bbrain(storm|storming)\b/i, 
                /\bconcept\b/i,
                /\binnovation\b/i,
                /\binvent(ion)?\b/i,
                /\bnotion\b/i,
                /\bmaybe\b/i, 
                /\bpossibly\b/i,
                /\bperhaps\b/i,
                /\bwhat\s+if\b/i,
                /\bthinking\s+about\b/i,
                /\bcould\b/i,
                /\bimagine\b/i,
                /\binspiration\b/i,
                /\bproposal\b/i,
                /\bsuggestion\b/i,
                /\bhypothesis\b/i,
                /\btheory\b/i,
                /\bvision\b/i,
                /\bperspective\b/i,
                /\bviewpoint\b/i,
                /\bopinion\b/i,
                /\bwonder(ing)?\b/i,
                /\bcurious\b/i,
                /\blet'?s\s+consider\b/i,
                /\binsight\b/i,
                /\bmight\s+be\b/i,
                /^what\s+about\b/i,
                /\bcreate\b/i,
                /\bdesign\b/i,
                /I\s+think\b/i,
                /I\s+believe\b/i,
                /I\s+feel\s+like\b/i,
                /\bmindmap\b/i,
                /\bbrainstorming\b/i,
                /\bplan\b/i,
                /\bconcept(ualize)?\b/i,
                /^(how|why)\s+/i,
                /^(what|where|when|which|who|why|how)\s+.+\?$/i,
                /^.+\?$/
            ],
            'Goal': [
                /\bgoal\b/i, 
                /\btarget\b/i, 
                /\bachieve(ment)?\b/i, 
                /\baspire\b/i,
                /\bambition\b/i,
                /\bresolution\b/i, 
                /\bmilestone\b/i, 
                /\bobjective\b/i,
                /\bdesire\b/i,
                /\bdream\b/i,
                /\bquest\b/i,
                /\bpurpose\b/i,
                /\bmission\b/i,
                /\bvision\b/i,
                /\baim\b/i,
                /\bintention\b/i,
                /\bplan\b/i,
                /\bstrategy\b/i,
                /\bcommitment\b/i,
                /\bdedication\b/i,
                /\bdiscipline\b/i,
                /\bperseverance\b/i,
                /\bchallenge\b/i,
                /\bstretch\b/i,
                /\bsuccess\b/i,
                /\bprogress\b/i,
                /\bgrowth\b/i,
                /\bmeasurement\b/i,
                /\bperformance\b/i,
                /\baccomplishment\b/i,
                /\bfulfillment\b/i,
                /\bi\s+want\s+to\b/i,
                /\bi\s+need\s+to\b/i,
                /\bi'?ll\b/i,
                /\bi\s+will\b/i,
                /\bi\s+should\b/i,
                /\bi\s+must\b/i,
                /\bby\s+the\s+end\s+of\b/i,
                /\bbefore\s+the\s+end\s+of\b/i,
                /\bin\s+\d+\s+(day|week|month|year)s?\b/i,
                /\bby\s+(january|february|march|april|may|june|july|august|september|october|november|december)\b/i,
                /\bby\s+\d{4}\b/,
                /\bby\s+next\b/i,
                /\bbecome\s+a\b/i,
                /\blearn\s+(to|how)\b/i,
                /\bmaster\b/i,
                /\bimprove\b/i,
                /\bincrease\b/i,
                /\bdecrease\b/i,
                /\breduce\b/i,
                /\bfocus\s+on\b/i
            ],
            'Note': [
                /\bnote\b/i, 
                /\binformation\b/i, 
                /\bfyi\b/i, 
                /\bdetails?\b/i, 
                /\bfact\b/i,
                /\bobservation\b/i,
                /\bcomment\b/i,
                /\breference\b/i,
                /\bknowledge\b/i,
                /\bdata\b/i,
                /\bresearch\b/i,
                /\bdocumentation\b/i,
                /\banalysis\b/i,
                /\bunderstanding\b/i,
                /\bperception\b/i,
                /\brealization\b/i,
                /\bsummary\b/i,
                /\brevision\b/i,
                /\bcontext\b/i,
                /\binteresting\b/i,
                /\blearned\b/i,
                /\bfound\s+out\b/i,
                /\bdiscovered\b/i,
                /\bto\s+research\b/i,
                /\bworth\s+noting\b/i,
                /\bworth\s+remembering\b/i,
                /\bwanted\s+to\s+say\b/i,
                /\bjust\s+saying\b/i,
                /\bfor\s+(your|my)\s+information\b/i,
                /\bin\s+case\s+you\b/i,
                /\bin\s+case\s+I\b/i,
                /\bdidn'?t\s+know\s+that\b/i,
                /\bnever\s+knew\b/i,
                /^here'?s\b/i,
                /^there'?s\b/i,
                /^this\s+is\b/i,
                /\bthat'?s\s+(interesting|odd|strange|funny|weird|curious|fascinating)\b/i,
                /^I\s+learned\b/i
            ]
        };
        
        // Additional meta-categories for more specific detection
        const metaCategories = {
            'Shopping': [
                /\bbuy\b/i,
                /\bpurchase\b/i,
                /\bget\b/i,
                /\bpick\s+up\b/i,
                /\border\b/i,
                /\bshipment\b/i,
                /\bdelivery\b/i,
                /\bstore\b/i,
                /\bshop\b/i,
                /\bmall\b/i,
                /\bmarket\b/i,
                /\bgrocery\b/i,
                /\bsupermarket\b/i,
                /\bamazon\b/i,
                /\bebay\b/i,
                /\bwish\s?list\b/i,
                /\bcart\b/i,
                /\bcheckout\b/i,
                /\bpayment\b/i,
                /\bproduct\b/i,
                /\bitem\b/i,
                /\bdiscount\b/i,
                /\bcoupon\b/i,
                /\bsale\b/i,
                /\bcost\b/i,
                /\bprice\b/i,
                /\bbudget\b/i,
            ],
            'Communication': [
                /\bcall\b/i,
                /\bemail\b/i,
                /\bmessage\b/i,
                /\btext\b/i,
                /\bsms\b/i,
                /\breply\b/i,
                /\brespond\b/i,
                /\bcontact\b/i,
                /\bphone\b/i,
                /\bvoicemail\b/i,
                /\banswer\b/i,
                /\bask\b/i,
                /\btell\b/i,
                /\bnotify\b/i,
                /\binform\b/i,
                /\balert\b/i,
                /\bupdate\b/i,
                /\brequest\b/i,
                /\bsend\b/i,
                /\bquestion\b/i,
                /\bchat\b/i,
                /\bdiscuss\b/i,
                /\bshare\b/i,
                /\bexplain\b/i,
                /\breachout\b/i,
            ],
            'Health': [
                /\bdoctor\b/i,
                /\bmedical\b/i,
                /\bhospital\b/i,
                /\bclinic\b/i,
                /\bappointment\b/i,
                /\bcheckup\b/i,
                /\bsymptom\b/i,
                /\billness\b/i,
                /\bpain\b/i,
                /\bmedicine\b/i,
                /\bmedication\b/i,
                /\bprescription\b/i,
                /\bpharmacy\b/i,
                /\bdrug\b/i,
                /\bpill\b/i,
                /\btablet\b/i,
                /\bdose\b/i,
                /\bvitamin\b/i,
                /\bsupplement\b/i,
                /\bexercise\b/i,
                /\bworkout\b/i,
                /\bjog\b/i,
                /\brun\b/i,
                /\bswim\b/i,
                /\bgymnasium\b/i,
                /\bgym\b/i,
                /\bdiet\b/i,
                /\bnutrition\b/i,
                /\bweight\b/i,
                /\bhealth(y)?\b/i,
                /\binjury\b/i,
                /\btherapy\b/i,
                /\brecovery\b/i,
                /\bheal(ing)?\b/i,
                /\bwellness\b/i,
                /\bfitness\b/i,
            ],
            'Personal': [
                /\bfamily\b/i,
                /\bfriend\b/i,
                /\brelative\b/i,
                /\bpartner\b/i,
                /\bspouse\b/i,
                /\bwife\b/i,
                /\bhusband\b/i,
                /\bchild\b/i,
                /\bkid\b/i,
                /\bdaughter\b/i,
                /\bson\b/i,
                /\bmother\b/i,
                /\bfather\b/i,
                /\bparent\b/i,
                /\bgrandparent\b/i,
                /\bsibling\b/i,
                /\bsister\b/i,
                /\bbrother\b/i,
                /\baunt\b/i,
                /\buncle\b/i,
                /\bcousin\b/i,
                /\bnephew\b/i,
                /\bniece\b/i,
                /\brelationship\b/i,
                /\bdate\b/i,
                /\bgirlfriend\b/i,
                /\bboyfriend\b/i,
                /\blove\b/i,
                /\bfeelings\b/i,
                /\bemotion\b/i,
                /\bself\b/i,
                /\bpersonal\b/i,
                /\bprivate\b/i,
                /\bintimate\b/i,
                /\bhobby\b/i,
                /\bpassion\b/i,
                /\binterest\b/i,
                /\bleisure\b/i,
                /\bfun\b/i,
                /\brecreation\b/i,
                /\bplay\b/i,
                /\brelax\b/i,
                /\brest\b/i,
                /\bvacation\b/i,
                /\bbreak\b/i,
                /\btime\s+off\b/i,
            ]
        };
        
        // Function to intelligently determine category based on text content
        function determineCategory(text) {
            // Return Task for empty or very short text
            if (!text || text.trim().length < 3) {
                return 'Task';
            }
            
            // Normalize text for analysis - lowercase and trimmed
            const normalizedText = text.trim().toLowerCase();
            
            // Start with a clean slate of scores
            const scores = {
                'Task': 0,
                'Work': 0,
                'Travel': 0,
                'Meeting': 0,
                'Reminder': 0, 
                'Idea': 0,
                'Goal': 0,
                'Note': 0
            };
            
            // FAST TRACK: Specific formats that are definitive indicators
            // ============================================================
            
            // Questions are almost always Ideas
            if (normalizedText.endsWith('?') || /^(what|how|why|when|where|who|which|can|could|would|should|is|are|will)\b.*\?$/i.test(normalizedText)) {
                return 'Idea';
            }
            
            // Bullet points or numbered items are Tasks
            if (/^([-•*✓✔☑☐]) |^\d+\.\s/.test(normalizedText)) {
                return 'Task';
            }
            
            // Date/time patterns strongly indicate Reminders
            const dateTimePatterns = [
                /\b(tomorrow|tonight|today|next week|next month|day after tomorrow)\b/i,
                /\b(mon|tues|wednes|thurs|fri|satur|sun)(day)?\b/i,
                /\bat\s+\d{1,2}(:\d{2})?\s*(am|pm)\b/i,
                /\b\d{1,2}(:\d{2})?\s*(am|pm)\b/i,
                /\bin\s+\d+\s+(minute|hour|day|week|month)/i,
                /\b\d{1,2}\/\d{1,2}(\/\d{2,4})?\b/,
                /\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]* \d{1,2}(st|nd|rd|th)?\b/i, // January 1st
                /\b\d{1,2}(st|nd|rd|th)? of (jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\b/i, // 1st of January
                /\bnext (monday|tuesday|wednesday|thursday|friday|saturday|sunday)\b/i,
                /\b(morning|afternoon|evening|night)\b/i,
                /\b(remind|remember|reminder|don't forget|alert|notification)\b/i
            ];
            
            for (const pattern of dateTimePatterns) {
                if (pattern.test(normalizedText)) {
                    scores['Reminder'] += 4;
                    // If multiple time patterns are found, it's even more likely to be a reminder
                    if (scores['Reminder'] >= 8) {
                        return 'Reminder';
                    }
                }
            }
            
            // Meeting indicators
            const meetingPatterns = [
                /\bmeeting\s+with\b/i,
                /\bcall\s+with\b/i,
                /\b(zoom|teams|webex|hangout|meet|google meet)\s+(call|meeting|conference|session)\b/i,
                /\b(meet|sync|catch\s+up|discuss|talk|chat)\s+with\s+[a-z]+/i,
                /\b(weekly|monthly|daily|quarterly|standup|sprint|planning|review|retro)\s+(meeting|sync|call)\b/i,
                /\b1:1\b|\bone on one\b|\b1 on 1\b/i,
                /\b(interview|presentation|workshop|conference)\b/i
            ];
            
            for (const pattern of meetingPatterns) {
                if (pattern.test(normalizedText)) {
                    scores['Meeting'] += 4;
                    if (scores['Meeting'] >= 4) {
                        return 'Meeting';
                    }
                }
            }
            
            // Travel indicators with expanded patterns
            const travelPatterns = [
                /\b(trip|travel|flight|hotel|book|reservation)\s+to\s+[a-z]+/i,
                /\bvisit(ing)?\s+[a-z]+/i,
                /\b(flight|train|bus|taxi|uber|lyft|car rental|departure|arrival)\b/i,
                /\b(vacation|holiday|getaway|tour|journey|expedition|excursion)\b/i,
                /\b(airport|station|terminal|gate|boarding|check-in)\b/i,
                /\b(passport|visa|itinerary|luggage|packing)\b/i
            ];
            
            for (const pattern of travelPatterns) {
                if (pattern.test(normalizedText)) {
                    scores['Travel'] += 3;
                    if (scores['Travel'] >= 3) {
                        return 'Travel';
                    }
                }
            }
            
            // Work-specific indicators
            const workPatterns = [
                /\b(project|client|report|document|presentation|deadline|deliverable)\b/i,
                /\b(boss|manager|supervisor|colleague|coworker|team)\b/i,
                /\b(email|report|analysis|research|document|proposal|contract)\b/i,
                /\b(review|approve|submit|send|prepare|quarterly|fiscal)\b/i,
                /\b(board|stakeholder|investor|customer|user|product|feature)\b/i
            ];
            
            for (const pattern of workPatterns) {
                if (pattern.test(normalizedText)) {
                    scores['Work'] += 2;
                }
            }
            
            // Goal indicators - first person commitments and more patterns
            const goalPatterns = [
                /^i\s+(want|need|will|plan|aim|hope|intend)\s+to\b/i,
                /\b(goal|objective|milestone|target|aim|resolution|aspiration)\b/i,
                /\b(achieve|accomplish|complete|finish|attain|reach|succeed)\b/i,
                /\b(challenge|improve|boost|enhance|increase|decrease|reduce)\b/i,
                /\b(by end of|within|next year|this year|this month|long term|short term)\b/i,
                /\b(progress|growth|development|advancement|career|promotion)\b/i
            ];
            
            for (const pattern of goalPatterns) {
                if (pattern.test(normalizedText)) {
                    scores['Goal'] += 3;
                    if (scores['Goal'] >= 6) {
                        return 'Goal';
                    }
                }
            }
            
            // Note pattern detection
            const notePatterns = [
                /\b(note|info|information|reference|summary|detail|fact|data)\b/i,
                /\b(fyi|for your info|remember that|take note)\b/i,
                /^(note:|info:|summary:|details:|important:)/i,
                /.+:.+:.+/i, // Detects structured notes with multiple colons
                /\b([a-z]+):([a-z]+)/i // Detects labeled data points
            ];
            
            for (const pattern of notePatterns) {
                if (pattern.test(normalizedText)) {
                    scores['Note'] += 2;
                }
            }
            
            // SIMPLE WORD ANALYSIS: Look for key terms that strongly indicate a category
            // ==========================================================================
            
            // Simple words/phrases that strongly indicate specific categories
            const simpleIndicators = {
                'Task': ['do', 'task', 'todo', 'finish', 'complete', 'handle', 'make', 'create', 'build', 'fix', 'solve', 'repair', 'update', 'modify', 'add', 'implement', 'install', 'configure', 'clean', 'arrange'],
                'Work': ['work', 'project', 'client', 'report', 'document', 'office', 'boss', 'colleague', 'deadline', 'job', 'business', 'corporate', 'company', 'department', 'team', 'meeting', 'presentation'],
                'Meeting': ['meeting', 'discuss', 'catch up', 'sync', 'standup', '1:1', 'meet with', 'call', 'conference', 'zoom', 'teams', 'hangout', 'webex', 'interview', 'consultation', 'briefing'],
                'Reminder': ['remind', 'remember', 'don\'t forget', 'reminder', 'appointment', 'schedule', 'calendar', 'date', 'time', 'alarm', 'alert', 'notification', 'upcoming', 'due'],
                'Idea': ['idea', 'thought', 'maybe', 'perhaps', 'what if', 'consider', 'thinking about', 'brainstorm', 'concept', 'suggestion', 'proposal', 'innovation', 'creativity', 'inspiration'],
                'Goal': ['goal', 'aim', 'achieve', 'objective', 'resolution', 'milestone', 'target', 'aspire', 'ambition', 'dream', 'vision', 'success', 'accomplish', 'attain', 'reach'],
                'Travel': ['travel', 'trip', 'visit', 'flight', 'hotel', 'vacation', 'journey', 'destination', 'tourism', 'holiday', 'booking', 'reservation', 'airport', 'itinerary', 'luggage', 'passport'],
                'Note': ['note', 'info', 'fyi', 'information', 'reference', 'summary', 'observation', 'detail', 'record', 'log', 'documentation', 'important', 'remember', 'highlight']
            };
            
            // Check for simple indicators
            for (const [category, indicators] of Object.entries(simpleIndicators)) {
                for (const word of indicators) {
                    // Check for whole word match
                    const regex = new RegExp(`\\b${word}\\b`, 'i');
                    if (regex.test(normalizedText)) {
                        scores[category] += 2;
                    }
                }
            }
            
            // CONTEXT ANALYSIS: Actions and contexts that indicate categories
            // ==============================================================
            
            // Shopping is a Task
            if (/\b(buy|purchase|get|pick up|shop for|order|acquire|procure)\b/i.test(normalizedText)) {
                scores['Task'] += 3;
            }
            
            // Communication is usually a Task
            if (/\b(call|email|text|message|contact|reply to|respond to|send|write to)\b/i.test(normalizedText) &&
                !/\b(meeting|discuss|talk about)\b/i.test(normalizedText)) {
                scores['Task'] += 2;
            }
            
            // Commands/imperative phrases indicate Tasks
            if (/^(please |kindly )?(make|create|do|add|remove|change|update|check|ensure|verify|set up|organize|arrange|prepare|schedule)/i.test(normalizedText)) {
                scores['Task'] += 3;
            }
            
            // Learning and improvement are Goals
            if (/\b(learn|improve|master|practice|study|train|develop|grow|progress|advance|gain|skill|expertise)\b/i.test(normalizedText)) {
                scores['Goal'] += 2;
            }
            
            // Maintenance and recurring tasks
            if (/\b(daily|weekly|monthly|regularly|routine|maintenance|upkeep|check up)\b/i.test(normalizedText)) {
                scores['Task'] += 2;
            }
            
            // Research and investigation suggest Ideas or Notes
            if (/\b(research|investigate|explore|analyze|study|examine|review|understand)\b/i.test(normalizedText)) {
                scores['Idea'] += 2;
                scores['Note'] += 1;
            }
            
            // Emotional or reflective content is often a Note
            if (/\b(feel|think|believe|opinion|perspective|reflection|thought|impression)\b/i.test(normalizedText)) {
                scores['Note'] += 2;
            }
            
            // LENGTH BASED ANALYSIS: Text length can indicate the type
            // ========================================================
            
            // Very short text is likely a Task
            if (normalizedText.length < 15) {
                scores['Task'] += 1;
            }
            
            // Longer text is more likely a Note
            if (normalizedText.length > 100) {
                scores['Note'] += Math.min(3, Math.floor(normalizedText.length / 50));
            } else if (normalizedText.length > 50) {
                scores['Note'] += 1;
            }
            
            // SENTENCE STRUCTURE ANALYSIS
            // ===========================
            
            // Count sentences - more sentences often indicate a Note
            const sentenceCount = (normalizedText.match(/[.!?]+\s/g) || []).length + 1;
            if (sentenceCount > 2) {
                scores['Note'] += sentenceCount - 1;
            }
            
            // Detect lists (bullet points, numbers, or dashes) which indicate Tasks
            const listPattern = normalizedText.split('\n').filter(line => /^[-*•]|\d+\./.test(line.trim())).length;
            if (listPattern > 0) {
                scores['Task'] += listPattern * 2;
            }
            
            // SPECIAL ADJUSTMENTS: Contextual adjustments based on combinations
            // =================================================================
            
            // If there's mention of both time and action, it's likely a Reminder
            if (scores['Reminder'] > 0 && scores['Task'] > 0) {
                scores['Reminder'] += 1;
            }
            
            // Strong future tense with goals words increases Goal likelihood
            if (/\bwill\s+[a-z]+\b|\bgoing\s+to\s+[a-z]+\b/i.test(normalizedText) && scores['Goal'] > 0) {
                scores['Goal'] += 2;
            }
            
            // RESULT CALCULATION: Find the highest score
            // ==========================================
            let bestCategory = 'Task'; // Default to Task for simplicity
            let maxScore = scores['Task']; // Start with Task score
            
            for (const [category, score] of Object.entries(scores)) {
                if (score > maxScore) {
                    maxScore = score;
                    bestCategory = category;
                }
            }
            
            // FALLBACK: If no clear winner, use these simple defaults
            // =======================================================
            if (maxScore === 0) {
                // If we have no signals at all, we use these simple defaults
                if (normalizedText.length < 20) return 'Task';
                if (normalizedText.split(' ').length <= 5) return 'Task';
                return 'Note';
            }
            
            return bestCategory;
        }
        
        // Get the highest card index from storage to continue counting
        function getHighestCardIndex() {
            const storedCards = getCardsFromStorage();
            if (storedCards.length === 0) return 0;
            
            return Math.max(...storedCards.map(card => card.index));
        }
        
        // Initialize card count from storage
        cardCount = getHighestCardIndex();
        
        // Function to reset input color
        function resetToDefaultColor() {
            pillBar.style.borderColor = defaultColor;
            pillBar.style.boxShadow = defaultShadow;
            
            // Hide category indicator
            const inlineCategory = document.querySelector('.inline-category');
            if (inlineCategory && inlineCategory.classList.contains('active')) {
                inlineCategory.classList.remove('active', 'animate');
                taskInput.classList.remove('with-category');
            }
        }
        
        // Function to update placeholder based on screen width
        function updatePlaceholder() {
            const width = window.innerWidth;
            if (width <= 380) {
                taskInput.placeholder = "Today's focus?";
            } else if (width <= 480) {
                taskInput.placeholder = "What's your goal today?";
            } else {
                taskInput.placeholder = "What are you getting done today?";
            }
        }
        
        // Function to check if task list is scrollable
        function checkScrollable(container) {
            if (container.scrollHeight > container.clientHeight) {
                container.classList.add('scrollable');
            } else {
                container.classList.remove('scrollable');
            }
        }
        
        // Format date and time
        function formatDateTime() {
            const now = new Date();
            const date = now.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric'
            });
            const time = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit'
            });
            
            return {
                dateStr: date,
                timeStr: time,
                fullStr: `${date} · ${time}`
            };
        }
        
        // Function to show notification
        function showNotification(message, duration = 3000) {
            const notification = document.querySelector('.notification');
            const messageElement = notification.querySelector('.notification-message');
            
            // Set message
            messageElement.textContent = message;
            
            // Show notification
            notification.classList.add('show');
            
            // Hide after duration
            setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }
        
        // Save all cards to local storage
        function saveCardsToStorage() {
            const cards = Array.from(document.querySelectorAll('.card'));
            const cardData = cards.map(card => {
                // Get absolute position values for the card
                const left = card.style.left;
                const top = card.style.top;
                
                // Extract card type from class
                let cardType = 'Task'; // Default
                const classMatch = card.className.match(/card-type-(\w+)/);
                if (classMatch && classMatch[1]) {
                    cardType = classMatch[1].charAt(0).toUpperCase() + classMatch[1].slice(1);
                }

                // Get tasks - handle both regular tasks and specialized content
                let tasks = [];
                if (cardType.toLowerCase() === 'note') {
                    // For Note cards, we store the note content
                    const noteContent = card.querySelector('.note-content');
                    if (noteContent) {
                        tasks = [{
                            isNote: true,
                            text: noteContent.innerHTML,
                            completed: false
                        }];
                    }
                } else {
                    // For other cards, get task items
                    tasks = Array.from(card.querySelectorAll('.task-item')).map(taskItem => {
                    const checkbox = taskItem.querySelector('.task-checkbox');
                    const taskText = taskItem.querySelector('.task-text');
                        const dateText = taskItem.querySelector('.date-text');
                        
                        // Handle date items for reminders
                        if (dateText) {
                    return {
                                isDate: true,
                                text: dateText.textContent,
                                completed: false
                            };
                        }
                        
                        return {
                            text: taskText ? taskText.textContent : '',
                            completed: checkbox ? checkbox.checked : false
                    };
                });
                }
                
                // Get special content like reminder times
                const reminderDateTime = card.querySelector('.reminder-datetime');
                const reminderData = {};
                
                if (reminderDateTime) {
                    const reminderDate = reminderDateTime.querySelector('.reminder-date');
                    const reminderTime = reminderDateTime.querySelector('.reminder-time');
                    
                    if (reminderDate) {
                        reminderData.date = reminderDate.textContent;
                    }
                    
                    if (reminderTime) {
                        reminderData.time = reminderTime.textContent;
                    }
                }
                
                return {
                    index: parseInt(card.dataset.index),
                    title: card.querySelector('.card-title').textContent,
                    color: card.style.background,
                    colorIndex: parseInt(card.dataset.colorIndex),
                    textColor: card.style.color || getTextColorForBackground(card.style.background),
                    category: cardType,
                    timestamp: card.querySelector('.card-timestamp').textContent,
                    tasks: tasks,
                    position: {
                        left: left || null,
                        top: top || null
                    },
                    moved: card.dataset.moved === 'true',
                    collapsed: card.classList.contains('collapsed'),
                    completed: card.classList.contains('completed'), // Save completed state
                    reminderData: Object.keys(reminderData).length > 0 ? reminderData : null
                };
            });
            
            localStorage.setItem(STORAGE_KEY, JSON.stringify(cardData));
        }
        
        // Function to clean up any ghost cards
        function cleanupGhostCards() {
            // Remove any cards with zero opacity that aren't being animated
            const cards = document.querySelectorAll('.card');
            cards.forEach(card => {
                const opacity = parseFloat(getComputedStyle(card).opacity);
                // If the card is nearly invisible and not being interacted with
                if (opacity < 0.1 && !card.classList.contains('dragging')) {
                    card.remove();
                }
            });
            
            // Update positions and save if updateCardStackPositions is defined
            if (typeof updateCardStackPositions === 'function') {
                updateCardStackPositions();
            }
        }
        
        // Function to reindex cards after deletion or completion
        function reindexCards() {
            // Get all cards that are not positioned (in the stack)
            const cards = Array.from(document.querySelectorAll('.card:not(.positioned)'));
            
            // Get highest index 
            let highestIndex = getHighestCardIndex();
            
            // Sort cards by current index (newest first)
            const sortedCards = cards.sort((a, b) => parseInt(b.dataset.index) - parseInt(a.dataset.index));
            
            // Reindex cards sequentially from highest to lowest
            sortedCards.forEach((card, idx) => {
                // Make sure indices are sequential
                card.dataset.index = highestIndex - idx;
            });
        }
        
        // Get cards from local storage
        function getCardsFromStorage() {
            const storedCards = localStorage.getItem(STORAGE_KEY);
            return storedCards ? JSON.parse(storedCards) : [];
        }
        
        // Load cards from storage
        function loadCardsFromStorage() {
            // Clear existing cards first to prevent duplicates
            const existingCards = document.querySelectorAll('.card');
            existingCards.forEach(card => card.remove());
            
            const storedCards = getCardsFromStorage();
            
            // Create each card from storage
            storedCards.forEach(cardData => {
                // Create a new card element
                const card = document.createElement('div');
                
                // Set the card type class based on the category
                const cardTypeLower = cardData.category.toLowerCase();
                card.className = `card card-type-${cardTypeLower}`;
                
                if (cardData.moved) {
                    card.classList.add('positioned');
                }
                
                // Add completed class if card was completed
                if (cardData.completed) {
                    card.classList.add('completed');
                }
                
                card.dataset.index = cardData.index;
                card.dataset.colorIndex = cardData.colorIndex;
                card.dataset.category = cardData.category;
                card.dataset.moved = cardData.moved.toString();
                card.style.background = cardData.color; // Use background instead of backgroundColor for gradients
                
                // Set text color based on saved value or calculate it
                card.style.color = cardData.textColor || getTextColorForBackground(cardData.color);
                
                // Position the card if it has been moved
                if (cardData.moved && cardData.position.left && cardData.position.top) {
                    card.style.position = 'fixed';
                    card.style.left = cardData.position.left;
                    card.style.top = cardData.position.top;
                    card.style.transform = 'none';
                    card.style.opacity = '1'; // Make sure it's visible
                }
                
                if (cardData.collapsed) {
                    card.classList.add('collapsed');
                }
                
                // Get the appropriate icon for the category
                let categoryIcon = getCategoryIcon(cardData.category);
                
                // Get specialized content like reminder date/time
                let specialContent = '';
                if (cardData.category === 'Reminder' && cardData.reminderData) {
                    specialContent = `
                        <div class="reminder-datetime">
                            ${cardData.reminderData.date ? `<span class="reminder-date">${cardData.reminderData.date}</span>` : ''}
                            ${cardData.reminderData.time ? `<span class="reminder-time">${cardData.reminderData.time}</span>` : ''}
                        </div>
                    `;
                }
                
                // Get customized text based on category
                let emptyStateText = 'Add steps to complete your task';
                let ctaText = 'Add step';
                
                switch(cardData.category) {
                    case 'Task':
                        emptyStateText = 'Add steps to complete your task';
                        ctaText = 'Add step';
                        break;
                    case 'Note':
                        emptyStateText = 'Capture your thoughts here';
                        ctaText = 'Add note';
                        break;
                    case 'Reminder':
                        emptyStateText = 'Add important dates or times';
                        ctaText = 'Add date';
                        break;
                    case 'Idea':
                        emptyStateText = 'Expand on your idea';
                        ctaText = 'Add point';
                        break;
                    case 'Meeting':
                        emptyStateText = 'Add meeting agenda items or notes';
                        ctaText = 'Add agenda item';
                        break;
                    case 'Goal':
                        emptyStateText = 'Break down your goal into milestones';
                        ctaText = 'Add milestone';
                        break;
                    case 'Work':
                        emptyStateText = 'List work tasks or deliverables';
                        ctaText = 'Add item';
                        break;
                    case 'Travel':
                        emptyStateText = 'Add destinations or travel items';
                        ctaText = 'Add destination';
                        break;
                }
                
                // Set the complete button text based on completion status
                const completeButtonText = cardData.completed ? 'Reopen Card' : 'Complete Card';
                
                // Create card content
                card.innerHTML = `
                    <div class="card-header">
                        <span class="card-tag">${categoryIcon}${cardData.category}</span>
                        <div class="card-header-controls">
                            <button class="card-due-date" title="Set due date">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="16" y1="2" x2="16" y2="6"></line>
                                    <line x1="8" y1="2" x2="8" y2="6"></line>
                                    <line x1="3" y1="10" x2="21" y2="10"></line>
                                </svg>
                            </button>
                            <button class="card-priority-flag" title="Set priority">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path>
                                    <line x1="4" y1="22" x2="4" y2="15"></line>
                                </svg>
                            </button>
                            <button class="card-complete-button" title="Mark as completed">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M20 6L9 17l-5-5"></path>
                                </svg>
                            </button>
                            <button class="toggle-collapse">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="18 15 12 9 6 15"></polyline>
                                </svg>
                            </button>
                            <button class="delete-card">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <h2 class="card-title" contenteditable="true">${cardData.title}</h2>
                    ${specialContent}
                    <div class="task-list-container">
                        <ul class="task-list"></ul>
                        <div class="empty-task-list" style="display: ${cardData.tasks.length > 0 ? 'none' : 'flex'}">
                            <svg viewBox="0 0 24 24" fill="none" stroke-width="1.5">
                                <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"></path>
                                <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                            </svg>
                            <p>${emptyStateText}</p>
                        </div>
                        <div class="scroll-indicator"></div>
                    </div>
                    <button class="add-step">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        ${ctaText}
                    </button>
                    <div class="card-footer">
                        <div class="color-picker" style="background-color: ${cardData.color};"></div>
                        <div class="card-timestamp">${cardData.timestamp}</div>
                    </div>
                `;
                
                // For Note type cards, we need to add the note content area
                if (cardData.category === 'Note') {
                    setTimeout(() => {
                        const taskList = card.querySelector('.task-list');
                        const noteArea = document.createElement('div');
                        noteArea.className = 'note-content';
                        noteArea.setAttribute('contenteditable', 'true');
                        noteArea.setAttribute('placeholder', 'Write your notes here...');
                        
                        // Add note content if it exists
                        if (cardData.tasks && cardData.tasks.length > 0 && cardData.tasks[0].isNote) {
                            noteArea.innerHTML = cardData.tasks[0].text;
                        }
                        
                        // Replace task list with note area
                        taskList.parentNode.insertBefore(noteArea, taskList);
                        taskList.style.display = 'none';
                        
                        // Hide empty state
                        const emptyState = card.querySelector('.empty-task-list');
                        if (emptyState) {
                            emptyState.style.display = 'none';
                        }
                    }, 100);
                } else {
                // Add tasks to the card
                const taskList = card.querySelector('.task-list');
                    
                    cardData.tasks.forEach(taskData => {
                    const taskItem = document.createElement('li');
                        
                        // Special handling for date items in Reminder cards
                        if (taskData.isDate) {
                            taskItem.className = 'task-item date-item';
                            taskItem.innerHTML = `
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="16" y1="2" x2="16" y2="6"></line>
                                    <line x1="8" y1="2" x2="8" y2="6"></line>
                                    <line x1="3" y1="10" x2="21" y2="10"></line>
                                </svg>
                                <div class="date-text" contenteditable="true">${taskData.text}</div>
                            `;
                        } else {
                            // Regular task items
                    taskItem.className = 'task-item';
                            
                            // Generate unique ID
                            const taskId = `task-${cardData.index}-${taskList.children.length}`;
                            
                    taskItem.innerHTML = `
                                <input type="checkbox" class="task-checkbox" id="${taskId}" ${taskData.completed ? 'checked' : ''}>
                                <div class="task-text" contenteditable="true">${taskData.text}</div>
                        <button class="delete-task">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    `;
                        }
                        
                    taskList.appendChild(taskItem);
                    });
                    
                    // Set up task event listeners
                    const tasks = card.querySelectorAll('.task-item');
                    tasks.forEach(task => {
                        // Skip setting up events for date items
                        if (task.classList.contains('date-item')) return;
                        
                        setupTaskItemEvents(task, card);
                    });
                }
                
                // Setup card events
                setupCardEvents(card);
                
                // Add event listener for the complete button
                const completeButton = card.querySelector('.card-complete-button');
                if (completeButton) {
                    completeButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent card dragging
                        
                        // Toggle completed state
                        const isCompleted = !card.classList.contains('completed');
                        
                        if (isCompleted) {
                            // Mark as completed
                            card.classList.add('completed');
                            
                            // If the card is not already collapsed, collapse it
                            if (!card.classList.contains('collapsed')) {
                                card.classList.add('collapsed');
                                
                                // Update toggle collapse button icon
                                const toggleCollapseButton = card.querySelector('.toggle-collapse svg polyline');
                                if (toggleCollapseButton) {
                                    toggleCollapseButton.setAttribute('points', '6 9 12 15 18 9');
                                }
                            }
                            
                            // Move to completed section
                            const completedContainer = document.querySelector('.completed-cards-container');
                            if (completedContainer) {
                                // Remove any positioning
                                card.dataset.moved = 'false';
                                card.style.position = '';
                                card.style.left = '';
                                card.style.top = '';
                                
                                // Move to completed section
                                completedContainer.appendChild(card);
                                
                                // Update the count
                                updateCompletedCount();
                                
                                // Update card stack positions to bring next card forward
                                reindexCards();
                                updateCardStackPositions();
                            }
                            
                            showNotification('Card marked as completed!');
                        } else {
                            // Mark as incomplete
                            card.classList.remove('completed');
                            
                            // Move back to main stack
                            const cardsStack = document.querySelector('.cards-stack');
                            if (cardsStack) {
                                cardsStack.appendChild(card);
                                
                                // Update the card positions
                                reindexCards();
                                updateCardStackPositions();
                                
                                // Update the count
                                updateCompletedCount();
                            }
                            
                            showNotification('Card reopened');
                        }
                        
                        // Update the tooltip
                        completeButton.title = isCompleted ? 'Mark as incomplete' : 'Mark as completed';
                        
                        // Update the storage
                        saveCardsToStorage();
                    });
                }
                
                // Add card to the appropriate container based on completion status
                if (cardData.completed) {
                    // Add to completed section
                    const completedContainer = document.querySelector('.completed-cards-container');
                    if (completedContainer) {
                        completedContainer.appendChild(card);
                    }
                } else {
                    // Add to main stack
                    cardsStack.appendChild(card);
                }
            });
            
            // Update the positions of all cards in the main stack
            updateCardStackPositions();
            
            // Update completed cards count
            updateCompletedCount();
        }
        
        // Helper function to get category icon
        function getCategoryIcon(category) {
            let icon = '';
            
            switch(category) {
                case 'Task':
                    icon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 11l3 3L22 4"></path>
                            <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
                        </svg>
                    `;
                    break;
                case 'Reminder':
                    icon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10 2v2"></path>
                            <path d="M6 6l-2-2"></path>
                            <path d="M14 6l2-2"></path>
                            <circle cx="10" cy="10" r="7"></circle>
                            <path d="M10 6v5l3 3"></path>
                        </svg>
                    `;
                    break;
                case 'Note':
                    icon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"></path>
                            <path d="M14 2v6h6"></path>
                            <path d="M16 13H8"></path>
                            <path d="M16 17H8"></path>
                            <path d="M10 9H8"></path>
                        </svg>
                    `;
                    break;
                case 'Idea':
                    icon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2a7 7 0 0 1 7 7c0 2.5-2 4.5-3 6.5-1 2-1 3-1 4.5-2 0-4 0-6 0 0-1.5 0-2.5-1-4.5-1-2-3-4-3-6.5a7 7 0 0 1 7-7Z"></path>
                            <path d="M9 16a3 3 0 0 0 6 0"></path>
                        </svg>
                    `;
                    break;
                case 'Meeting':
                    icon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                    `;
                    break;
                case 'Goal':
                    icon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="6"></circle>
                            <circle cx="12" cy="12" r="2"></circle>
                        </svg>
                    `;
                    break;
                case 'Work':
                    icon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect>
                            <path d="M16 21V5a2 2 0 00-2-2h-4a2 2 0 00-2 2v16"></path>
                        </svg>
                    `;
                    break;
                case 'Travel':
                    icon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 17h18"></path>
                            <path d="m16 10-4-4-4 4"></path>
                            <path d="M12 6v9"></path>
                        </svg>
                    `;
                    break;
                default:
                    icon = '';
            }
            
            return icon;
        }
        
        // Update positions only for cards in the stack (not manually positioned)
        function updateCardStackPositions() {
            const cards = Array.from(document.querySelectorAll('.card:not(.positioned)'));
            
            // Sort all cards by their index (newest first)
            const sortedCards = cards.sort((a, b) => parseInt(b.dataset.index) - parseInt(a.dataset.index));
            
            // Position each card in the stack
            sortedCards.forEach((card, index) => {
                // Base position is centered
                card.style.opacity = 1;
                
                if (index === 0) {
                    // The newest card is centered
                    card.style.zIndex = 100;
                    card.style.transform = 'translateX(0) scale(1) rotate(0deg)';
                } else if (index < 10) {
                    // First 10 cards visible in a fan
                    const rotation = 4 * index;
                    const zIndex = 100 - index;
                    const opacity = 1 - (index * 0.06);
                    const offsetX = (25 * index);
                    const scale = 1 - (index * 0.03);
                    
                    // Apply transform
                    card.style.zIndex = zIndex;
                    card.style.opacity = opacity;
                    card.style.transform = `translateX(${offsetX}px) scale(${scale}) rotate(${rotation}deg)`;
                } else {
                    // Remaining cards stacked behind with minimal visibility
                    card.style.zIndex = 90 - (index % 10);
                    card.style.opacity = 0.2;
                    card.style.transform = `translateX(220px) scale(0.7) rotate(15deg)`;
                }
            });
            
            // Save to storage after positioning
            saveCardsToStorage();
        }
        
        // Function to setup task item events
        function setupTaskItemEvents(taskItem, card) {
            const deleteTaskButton = taskItem.querySelector('.delete-task');
            const checkbox = taskItem.querySelector('.task-checkbox');
            
            // Add delete functionality for the task
            deleteTaskButton.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Apply fade out animation
                taskItem.style.opacity = '0';
                taskItem.style.height = '0';
                taskItem.style.marginBottom = '0';
                taskItem.style.paddingBottom = '0';
                
                // Remove after animation
                setTimeout(() => {
                    taskItem.remove();
                    
                    // Show empty state if no tasks left
                    const taskList = card.querySelector('.task-list');
                    if (taskList.children.length === 0) {
                        const emptyState = card.querySelector('.empty-task-list');
                        if (emptyState) {
                            emptyState.style.display = 'flex';
                        }
                    }
                    
                    // Update timestamp
                    const newDateTime = formatDateTime();
                    card.querySelector('.card-timestamp').textContent = newDateTime.fullStr;
                    
                    // Save to storage
                    saveCardsToStorage();
                }, 200);
            });
            
            // Add event listener for checkbox changes
            checkbox.addEventListener('change', () => {
                // Update timestamp
                const newDateTime = formatDateTime();
                card.querySelector('.card-timestamp').textContent = newDateTime.fullStr;
                
                // Save to storage
                saveCardsToStorage();
            });
            
            // Make the task text editable
            const taskText = taskItem.querySelector('.task-text');
            taskText.addEventListener('blur', () => {
                saveCardsToStorage();
            });
        }
        
        // Setup all card event listeners
        function setupCardEvents(card) {
            // Make card draggable
            makeDraggable(card);
            
            // Add collapse/expand functionality
            const toggleCollapseButton = card.querySelector('.toggle-collapse');
            toggleCollapseButton.addEventListener('click', (e) => {
                e.stopPropagation();
                
                card.classList.toggle('collapsed');
                
                // Update the icon based on collapsed state
                if (card.classList.contains('collapsed')) {
                    toggleCollapseButton.innerHTML = `
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    `;
                } else {
                    toggleCollapseButton.innerHTML = `
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="18 15 12 9 6 15"></polyline>
                        </svg>
                    `;
                }
                
                // Update card positions after collapsing/expanding
                setTimeout(updateCardStackPositions, 50);
                
                // Save to storage
                saveCardsToStorage();
            });
            
            // Add flag button functionality
            const flagButton = card.querySelector('.card-priority-flag');
            // Use setupFlagPriorityButton from flag_priority.js
            setupFlagPriorityButton(flagButton);

            // Add title editing functionality
            const cardTitle = card.querySelector('.card-title');
            cardTitle.addEventListener('focus', () => {
                // Save original text to restore if editing is cancelled
                cardTitle.dataset.originalText = cardTitle.textContent;
            });
            
            cardTitle.addEventListener('blur', () => {
                // Update timestamp when title is edited
                const newDateTime = formatDateTime();
                card.querySelector('.card-timestamp').textContent = newDateTime.fullStr;
                
                // Don't allow empty titles
                if (cardTitle.textContent.trim() === '') {
                    cardTitle.textContent = cardTitle.dataset.originalText || 'Untitled';
                }
                
                // Save to storage
                saveCardsToStorage();
            });
            
            cardTitle.addEventListener('keydown', (e) => {
                // Prevent new lines in title (Enter key)
                if (e.key === 'Enter') {
                    e.preventDefault();
                    cardTitle.blur();
                }
                // Cancel editing on Escape
                if (e.key === 'Escape') {
                    cardTitle.textContent = cardTitle.dataset.originalText;
                    cardTitle.blur();
                }
            });
            
            // Add delete card functionality
            const deleteButton = card.querySelector('.delete-card');
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                
                const confirmDeleteCards = localStorage.getItem('confirmDeleteCards') !== 'false';
                
                if (!confirmDeleteCards || confirm('Are you sure you want to delete this card?')) {
                    // Premium instant deletion with subtle animation
                    // The animation is so quick it feels instantaneous but adds a premium feel
                    card.style.animation = 'deleteCardPremium 0.08s forwards';
                    
                    // Remove card after the super-fast animation
                    // Use requestAnimationFrame for smoother handling
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            card.remove();
                            
                            // Fix stack positioning by reindexing cards
                            reindexCards();
                            updateCardStackPositions();
                            saveCardsToStorage();
                        });
                    });
                }
            });
            
            // Add color picker functionality
            const colorPicker = card.querySelector('.color-picker');
            colorPicker.addEventListener('click', (e) => {
                e.stopPropagation();
                
                let currentColorIdx = parseInt(card.dataset.colorIndex);
                currentColorIdx = (currentColorIdx + 1) % cardColors.length;
                
                const newColor = cardColors[currentColorIdx];
                card.style.background = newColor;
                colorPicker.style.background = newColor;
                card.dataset.colorIndex = currentColorIdx;
                
                // Determine appropriate text color based on background
                const textColor = getTextColorForBackground(newColor);
                card.style.color = textColor;
                
                // Update timestamp
                const newDateTime = formatDateTime();
                card.querySelector('.card-timestamp').textContent = newDateTime.fullStr;
                
                // Save to storage
                saveCardsToStorage();
            });
            
            
            // Add step functionality
            const addStepButton = card.querySelector('.add-step');
            addStepButton.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Hide empty state if present
                const emptyState = card.querySelector('.empty-task-list');
                if (emptyState) {
                    emptyState.style.display = 'none';
                }
                
                const taskList = card.querySelector('.task-list');
                const newItemIndex = taskList.children.length;
                const newItem = document.createElement('li');
                newItem.className = 'task-item';
                
                // Generate unique ID
                const taskId = `task-${card.dataset.index}-${newItemIndex}`;
                
                newItem.innerHTML = `
                    <input type="checkbox" class="task-checkbox" id="${taskId}">
                    <div class="task-text" contenteditable="true"></div>
                    <button class="delete-task">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                `;
                
                taskList.appendChild(newItem);
                
                // Setup task event listeners
                setupTaskItemEvents(newItem, card);
                
                // Make the text editable and focus it
                const taskText = newItem.querySelector('.task-text');
                taskText.focus();
                
                // Update timestamp
                const newDateTime = formatDateTime();
                card.querySelector('.card-timestamp').textContent = newDateTime.fullStr;
                
                // Check if scrollable
                const container = card.querySelector('.task-list-container');
                setTimeout(() => checkScrollable(container), 10);
                
                // Save to storage
                saveCardsToStorage();
            });
        }
        
        // Load cards when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Clear any existing cards
            const existingCards = document.querySelectorAll('.card');
            existingCards.forEach(card => card.remove());
            
            // Load cards from storage
            loadCardsFromStorage();
            
            // Clean up any ghost cards after a short delay
            setTimeout(cleanupGhostCards, 1000);
        });
        
        // Initial placeholder update
        updatePlaceholder();
        
        // Update placeholder on resize
        window.addEventListener('resize', updatePlaceholder);
        
        // Listen for input events (when user types)
        taskInput.addEventListener('input', (e) => {
            // Clear any existing timeout
            clearTimeout(typingTimer);
            
            // Get the next color and update the border
            currentColorIndex = (currentColorIndex + 1) % cardColors.length;
            const currentColor = cardColors[currentColorIndex];
            pillBar.style.borderColor = currentColor;
            
            // Add a subtle glow effect based on the current color
            pillBar.style.boxShadow = `0 0 8px ${currentColor}50, 0 2px 10px rgba(0, 0, 0, 0.5)`;
            
            // Show the detected category in the UI only if there's actual text
            const hasText = taskInput.value.trim() !== '';
            const predictedCategory = hasText ? determineCategory(taskInput.value) : '';
            
            // Update the inline category indicator
            const inlineCategory = document.querySelector('.inline-category');
            
            if (hasText && predictedCategory) {
                // Update text and show it
                inlineCategory.textContent = predictedCategory;
                
                // If we're changing category, add animation class
                if (!inlineCategory.classList.contains('active') || 
                    inlineCategory.dataset.lastCategory !== predictedCategory) {
                    
                    inlineCategory.classList.remove('animate');
                    void inlineCategory.offsetWidth; // Force reflow to restart animation
                    inlineCategory.classList.add('animate');
                    inlineCategory.dataset.lastCategory = predictedCategory;
                }
                
                // Activate the category and add padding to input
                inlineCategory.classList.add('active');
                taskInput.classList.add('with-category');
                
                // Assign color to match the current typing color
                inlineCategory.style.color = currentColor;
            } else {
                // Hide the category if no text
                inlineCategory.classList.remove('active', 'animate');
                taskInput.classList.remove('with-category');
            }
            
            // Set a timer to reset the color after a pause in typing
            typingTimer = setTimeout(resetToDefaultColor, typingTimeout);
        });
        
        // Handle form submission (Enter key)
        taskInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && taskInput.value.trim() !== '') {
                // Get random color for the card
                const randomColorIndex = Math.floor(Math.random() * cardColors.length);
                const cardColor = cardColors[randomColorIndex];
                
                // Create new card with entered text
                createCard(taskInput.value, cardColor);
                
                // Clear input
                taskInput.value = '';
                
                // Reset color
                resetToDefaultColor();
                currentColorIndex = 0;
            }
        });
        
        // Reset border color when input is cleared
        taskInput.addEventListener('change', () => {
            if (!taskInput.value) {
                resetToDefaultColor();
                currentColorIndex = 0;
            }
        });
        
        // Also reset when the input loses focus
        taskInput.addEventListener('blur', () => {
            resetToDefaultColor();
        });
        
        // But keep the color when input has focus
        taskInput.addEventListener('focus', () => {
            if (taskInput.value) {
                const currentColor = cardColors[currentColorIndex];
                pillBar.style.borderColor = currentColor;
                pillBar.style.boxShadow = `0 0 8px ${currentColor}50, 0 2px 10px rgba(0, 0, 0, 0.5)`;
                
                // Set the timer again
                clearTimeout(typingTimer);
                typingTimer = setTimeout(resetToDefaultColor, typingTimeout);
            }
        });
        
        // Make mic button also change colors on click
        micButton.addEventListener('click', () => {
            // Toggle listening state
            if (isListening) {
                // If already listening, stop speech recognition
                if (recognitionInstance) {
                    recognitionInstance.stop();
                }
                micButton.style.color = '';
                micButton.classList.remove('listening');
                isListening = false;
                showNotification('Voice recognition turned off');
                return;
            }
            
            // Check if the SpeechRecognition API is available
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showNotification('Speech recognition is not supported in your browser. Try Chrome or Edge.');
                return;
            }
            
            // Visual feedback
            currentColorIndex = (currentColorIndex + 1) % 8; // Use only dark colors
            const currentColor = cardColors[currentColorIndex];
            pillBar.style.borderColor = currentColor;
            
            // Add listening class for animation
            micButton.classList.add('listening');
            micButton.style.color = 'white';
            isListening = true;
            
            try {
                // Create speech recognition object
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognitionInstance = new SpeechRecognition();
                
                // Configure recognition for continuous listening
                recognitionInstance.lang = 'en-US';
                recognitionInstance.interimResults = true; // Get results as you speak
                recognitionInstance.maxAlternatives = 1;
                recognitionInstance.continuous = true; // Keep listening
                
                // Current speech buffer
                let currentSpeech = '';
                
                // Start listening
                recognitionInstance.start();
                console.log('Speech recognition started');
                
                // Show visual indicator for listening state
                showNotification('Listening mode active. Click mic to stop.');
                
                // Handle keydown to create cards with Enter
                const keydownHandler = function(e) {
                    if (e.key === 'Enter' && taskInput.value.trim() !== '') {
                        e.preventDefault();
                        
                        // Create a card with current text
                        const cardColor = getRandomDarkShade();
                        createCard(taskInput.value, cardColor);
                        
                        // Clear the input and speech buffer
                        currentSpeech = '';
                        taskInput.value = '';
                        
                        showNotification('Card created! Continue speaking or click mic to stop.');
                    }
                };
                
                // Add the keydown listener
                document.addEventListener('keydown', keydownHandler);
                
                // Handle speech recognition results
                recognitionInstance.onresult = function(event) {
                    try {
                        const results = event.results;
                        const latestResult = results[results.length - 1];
                        
                        if (!latestResult.isFinal) {
                            // Show interim results
                            const transcript = latestResult[0].transcript;
                            taskInput.value = currentSpeech + transcript;
                        } else {
                            // Update with final results
                            currentSpeech += latestResult[0].transcript + ' ';
                            taskInput.value = currentSpeech;
                        }
                    } catch (error) {
                        console.error('Error processing speech:', error);
                        showNotification('Error processing speech. Please try again.');
                    }
                };
                
                // Handle speech recognition end
                recognitionInstance.onend = function() {
                    console.log('Speech recognition ended');
                    
                    // If we're still supposed to be listening, restart it
                    if (isListening) {
                        try {
                            recognitionInstance.start();
                            console.log('Speech recognition restarted');
                        } catch (error) {
                            console.error('Failed to restart speech recognition:', error);
                            // If restart fails, clean up
                            micButton.classList.remove('listening');
                            micButton.style.color = '';
                            isListening = false;
                            document.removeEventListener('keydown', keydownHandler);
                            showNotification('Speech recognition stopped unexpectedly');
                        }
                    } else {
                        // Proper cleanup
                        micButton.classList.remove('listening');
                        micButton.style.color = '';
                        document.removeEventListener('keydown', keydownHandler);
                    }
                };
                
                // Handle speech recognition errors
                recognitionInstance.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    
                    // Don't show no-speech error in continuous mode
                    if (event.error !== 'no-speech') {
                        switch(event.error) {
                            case 'audio-capture':
                                showNotification('No microphone found. Please check your microphone.');
                                break;
                            case 'not-allowed':
                                showNotification('Microphone access denied. Please allow microphone access.');
                                break;
                            case 'network':
                                showNotification('Network error. Please check your connection.');
                                break;
                            default:
                                showNotification('Speech recognition error: ' + event.error);
                        }
                    }
                    
                    // Fatal errors should stop listening
                    if (['audio-capture', 'not-allowed', 'network', 'service-not-allowed'].includes(event.error)) {
                        micButton.classList.remove('listening');
                        micButton.style.color = '';
                        isListening = false;
                        document.removeEventListener('keydown', keydownHandler);
                    }
                };
                
            } catch (error) {
                console.error('Failed to initialize speech recognition:', error);
                showNotification('Speech recognition failed to initialize');
                micButton.classList.remove('listening');
                micButton.style.color = '';
                isListening = false;
            }
        });
        
        // Settings button color change and subtle animation on click
        settingsButton.addEventListener('click', () => {
            const currentColor = cardColors[currentColorIndex];
            settingsButton.style.color = currentColor;
            settingsButton.style.transform = 'rotate(90deg)';
            
            setTimeout(() => {
                settingsButton.style.color = '';
                settingsButton.style.transform = '';
            }, 800);
        });

        // Settings and theme functionality
        document.addEventListener('DOMContentLoaded', () => {
            // Settings modal elements
            const settingsButton = document.querySelector('.settings-button');
            const settingsModal = document.querySelector('.settings-modal');
            const closeSettingsButton = document.querySelector('.close-settings-btn');
            
            // Navigation elements
            const navItems = document.querySelectorAll('.nav-item');
            const settingsPanels = document.querySelectorAll('.settings-panel');
            
            // Theme toggle buttons
            const darkModeBtn = document.getElementById('dark-mode-btn');
            const lightModeBtn = document.getElementById('light-mode-btn');
            
            // Font size slider
            const fontSizeSlider = document.getElementById('font-size-slider');
            const fontSizeValue = document.querySelector('.slider-value');
            
            // Cards settings
            const maxCardsSelect = document.getElementById('max-cards-setting');
            const showTimestampsCheckbox = document.getElementById('show-timestamps');
            const showCategoriesCheckbox = document.getElementById('show-categories');
            const showCompletedCardsCheckbox = document.getElementById('show-completed-cards');
            
            // Get stored preferences
            const storedTheme = localStorage.getItem('theme') || 'dark';
            const storedFontSize = localStorage.getItem('fontSize') || '100';
            const storedMaxCards = localStorage.getItem('maxCards') || '10';
            const storedShowTimestamps = localStorage.getItem('showTimestamps') !== 'false'; // default to true
            const storedShowCategories = localStorage.getItem('showCategories') !== 'false'; // default to true
            const storedShowCompletedCards = localStorage.getItem('showCompletedCards') !== 'false'; // default to true
            const storedCollapseNewCards = localStorage.getItem('collapseNewCards') === 'true'; // default to false
            const storedConfirmDeleteCards = localStorage.getItem('confirmDeleteCards') !== 'false'; // default to true
            
            // Apply stored theme on load
            if (storedTheme === 'light') {
                document.body.classList.add('light-mode');
                document.body.classList.remove('dark-mode');
                darkModeBtn.classList.remove('active');
                lightModeBtn.classList.add('active');
            } else {
                document.body.classList.add('dark-mode');
                document.body.classList.remove('light-mode');
                darkModeBtn.classList.add('active');
                lightModeBtn.classList.remove('active');
            }
            
            // Apply stored card collapse preference
            const collapseNewCardsCheckbox = document.getElementById('collapse-new-cards');
            if (collapseNewCardsCheckbox) {
                collapseNewCardsCheckbox.checked = storedCollapseNewCards;
            }
            
            // Handle collapse new cards setting
            if (collapseNewCardsCheckbox) {
                collapseNewCardsCheckbox.addEventListener('change', () => {
                    const collapseNewCards = collapseNewCardsCheckbox.checked;
                    localStorage.setItem('collapseNewCards', collapseNewCards);
                    showNotification(`New cards will ${collapseNewCards ? 'be collapsed' : 'expand'} by default`);
                });
            }
            
            // Apply stored confirmation dialog preference
            const confirmDeleteCardsCheckbox = document.getElementById('confirm-delete-cards');
            if (confirmDeleteCardsCheckbox) {
                confirmDeleteCardsCheckbox.checked = storedConfirmDeleteCards;
                
                confirmDeleteCardsCheckbox.addEventListener('change', () => {
                    const confirmDeleteCards = confirmDeleteCardsCheckbox.checked;
                    localStorage.setItem('confirmDeleteCards', confirmDeleteCards);
                    showNotification(`Card deletion confirmation dialog ${confirmDeleteCards ? 'enabled' : 'disabled'}`);
                });
            }
            
            // Modify createCard function to respect collapse preference
            function createCard(text, color) {
                // ... existing createCard code ...
                
                // After creating the card, check if it should be collapsed
                const collapseNewCards = localStorage.getItem('collapseNewCards') === 'true';
                if (collapseNewCards) {
                    card.classList.add('collapsed');
                    const toggleCollapseButton = card.querySelector('.toggle-collapse');
                    if (toggleCollapseButton) {
                        toggleCollapseButton.innerHTML = `
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        `;
                    }
                }
                
                // ... rest of createCard code ...
            }
            
            // Date/Time Picker functionality
            let currentDateTimeCard = null;
            
            function showDateTimePicker(card, event) {
                const picker = document.getElementById('date-time-picker');
                currentDateTimeCard = card;
                
                // Position the picker near the button
                const rect = event.target.getBoundingClientRect();
                picker.style.left = rect.left + 'px';
                picker.style.top = (rect.bottom + 5) + 'px';
                
                // Show the picker
                picker.style.display = 'block';
                
                // Initialize calendar if needed
                initializeCalendar();
            }
            
            // Make this function globally accessible
            function closeDateTimePicker() {
                const picker = document.getElementById('date-time-picker');
                if (picker) {
                    picker.style.display = 'none';
                    currentDateTimeCard = null;
                }
            }
            // Also expose it globally for the cancel button
            window.closeDateTimePicker = closeDateTimePicker;
            
            function initializeCalendar(date = new Date()) {
                const container = document.getElementById('calendar-container');
                const currentMonth = date.getMonth();
                const currentYear = date.getFullYear();
                const today = new Date();
                
                // Create calendar header
                const header = document.createElement('div');
                header.className = 'calendar-header';
                header.innerHTML = `
                    <button class="prev-month">←</button>
                    <span>${new Date(currentYear, currentMonth).toLocaleString('default', { month: 'long', year: 'numeric' })}</span>
                    <button class="next-month">→</button>
                `;
                
                // Create calendar grid
                const grid = document.createElement('div');
                grid.className = 'calendar-grid';
                
                // Add day headers
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                days.forEach(day => {
                    const dayHeader = document.createElement('div');
                    dayHeader.className = 'calendar-day-header';
                    dayHeader.textContent = day;
                    grid.appendChild(dayHeader);
                });
                
                // Add date cells
                const firstDay = new Date(currentYear, currentMonth, 1);
                const lastDay = new Date(currentYear, currentMonth + 1, 0);
                const startPadding = firstDay.getDay();
                const totalDays = lastDay.getDate();
                
                // Add padding for start of month
                for (let i = 0; i < startPadding; i++) {
                    const paddingCell = document.createElement('div');
                    paddingCell.className = 'calendar-day padding';
                    grid.appendChild(paddingCell);
                }
                
                // Add days of the month
                for (let day = 1; day <= totalDays; day++) {
                    const dateCell = document.createElement('div');
                    dateCell.className = 'calendar-day';
                    if (day === today.getDate() && currentMonth === today.getMonth() && currentYear === today.getFullYear()) {
                        dateCell.classList.add('today');
                    }
                    dateCell.textContent = day;
                    dateCell.addEventListener('click', () => selectDate(new Date(currentYear, currentMonth, day)));
                    grid.appendChild(dateCell);
                }
                
                // Clear container and add new calendar
                container.innerHTML = '';
                container.appendChild(header);
                container.appendChild(grid);
                
                // Add event listeners for month navigation
                const prevButton = header.querySelector('.prev-month');
                const nextButton = header.querySelector('.next-month');
                
                prevButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const newDate = new Date(currentYear, currentMonth - 1);
                    initializeCalendar(newDate);
                });
                
                nextButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const newDate = new Date(currentYear, currentMonth + 1);
                    initializeCalendar(newDate);
                });

                // Add event listeners to make days selectable
                const dayCells = grid.querySelectorAll('.calendar-day:not(.padding)');
                dayCells.forEach(cell => {
                    cell.addEventListener('click', function() {
                        // Clear previous selection
                        dayCells.forEach(c => c.classList.remove('selected'));
                        // Mark this day as selected
                        this.classList.add('selected');
                    });
                });
            }
            
            function selectDate(date) {
                if (!currentDateTimeCard) return;
                
                // Format the date
                const formattedDate = date.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric'
                });
                
                // Get the time values
                const hours = document.getElementById('hours').value;
                const minutes = document.getElementById('minutes').value;
                const period = document.getElementById('period').value;
                
                // Format the time
                const formattedTime = `${hours}:${minutes.toString().padStart(2, '0')} ${period}`;
                
                // Update the card with the selected date and time
                updateCardDateTime(currentDateTimeCard, formattedDate, formattedTime);
                
                // Clear previous selections and mark this day as selected
                const dayCells = document.querySelectorAll('.calendar-day:not(.padding)');
                dayCells.forEach(cell => cell.classList.remove('selected'));
                
                // Find the day cell that matches the selected date and mark as selected
                const day = date.getDate();
                const dayCell = Array.from(dayCells).find(cell => parseInt(cell.textContent) === day);
                if (dayCell) {
                    dayCell.classList.add('selected');
                }
                
                // No need to close the picker, as we now use setDateTime() for that
            }
            
            function setDateTime() {
                if (!currentDateTimeCard) return;
                
                // Get the selected date from the calendar
                const selectedDay = document.querySelector('.calendar-day.selected');
                if (!selectedDay) {
                    // If no day is selected, use today's date
                    const today = new Date();
                    const formattedDate = today.toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric'
                    });
                    
                    // Get the time values
                    const hours = document.getElementById('hours').value;
                    const minutes = document.getElementById('minutes').value;
                    const period = document.getElementById('period').value;
                    
                    // Format the time
                    const formattedTime = `${hours}:${minutes.toString().padStart(2, '0')} ${period}`;
                    
                    // Update the card with the selected date and time
                    updateCardDateTime(currentDateTimeCard, formattedDate, formattedTime);
                } else {
                    // Use the selected date
                    const monthYear = document.querySelector('.calendar-header span').textContent;
                    const day = parseInt(selectedDay.textContent);
                    const date = new Date(`${monthYear} ${day}, ${new Date().getFullYear()}`);
                    
                    // Format the date
                    const formattedDate = date.toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric'
                    });
                    
                    // Get the time values
                    const hours = document.getElementById('hours').value;
                    const minutes = document.getElementById('minutes').value;
                    const period = document.getElementById('period').value;
                    
                    // Format the time
                    const formattedTime = `${hours}:${minutes.toString().padStart(2, '0')} ${period}`;
                    
                    // Update the card with the selected date and time
                    updateCardDateTime(currentDateTimeCard, formattedDate, formattedTime);
                }
                
                // Close the picker
                closeDateTimePicker();
            }
            
            function updateCardDateTime(card, date, time) {
                // Update or create the reminder datetime display
                let reminderDateTime = card.querySelector('.reminder-datetime');
                if (!reminderDateTime) {
                    reminderDateTime = document.createElement('div');
                    reminderDateTime.className = 'reminder-datetime';
                    const cardTitle = card.querySelector('.card-title');
                    cardTitle.after(reminderDateTime);
                }
                
                reminderDateTime.innerHTML = `
                    <span class="reminder-date">${date}</span>
                    <span class="reminder-time">${time}</span>
                `;
                
                // Add reminder badge if one is selected
                const selectedReminder = document.getElementById('reminder-select');
                if (selectedReminder && selectedReminder.value !== 'none') {
                    const minutes = parseInt(selectedReminder.value);
                    const reminderText = minutes === 60 ? '1 hour before' : `${minutes} min before`;
                    
                    const reminderBadge = document.createElement('span');
                    reminderBadge.className = 'reminder-badge';
                    reminderBadge.innerHTML = `
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10 2v2"></path>
                            <path d="M6 6l-2-2"></path>
                            <path d="M14 6l2-2"></path>
                            <circle cx="10" cy="10" r="7"></circle>
                            <path d="M10 6v5l3 3"></path>
                        </svg>
                        ${reminderText}
                    `;
                    reminderDateTime.appendChild(reminderBadge);
                }
                
                // Save to storage
                saveCardsToStorage();
            }
            
            // Add click handler for the due date button
            document.addEventListener('click', (e) => {
                if (e.target.closest('.card-due-date')) {
                    const card = e.target.closest('.card');
                    if (card) {
                        showDateTimePicker(card, e);
                    }
                }
            });
            
            // Close date picker when clicking outside
            document.addEventListener('click', (e) => {
                const picker = document.getElementById('date-time-picker');
                const isClickInside = e.target.closest('.date-picker-container') || e.target.closest('.card-due-date');
                
                if (picker && picker.style.display === 'block' && !isClickInside) {
                    closeDateTimePicker();
                }
            });
            
            // Apply stored font size
            if (fontSizeSlider) {
                fontSizeSlider.value = storedFontSize;
                fontSizeValue.textContent = `${storedFontSize}%`;
                document.documentElement.style.fontSize = `${storedFontSize}%`;
            }
            
            // Apply stored card settings
            if (maxCardsSelect) {
                maxCardsSelect.value = storedMaxCards;
                // Update the maxVisibleCards variable
                window.maxVisibleCards = parseInt(storedMaxCards);
            }
            
            // Apply stored timestamp visibility
            if (showTimestampsCheckbox) {
                showTimestampsCheckbox.checked = storedShowTimestamps;
                updateTimestampVisibility(storedShowTimestamps);
            }
            
            // Apply stored category visibility
            if (showCategoriesCheckbox) {
                showCategoriesCheckbox.checked = storedShowCategories;
                updateCategoryVisibility(storedShowCategories);
            }
            
            // Apply stored completed cards section visibility
            if (showCompletedCardsCheckbox) {
                showCompletedCardsCheckbox.checked = storedShowCompletedCards;
                updateCompletedCardsVisibility(storedShowCompletedCards);
            }
            
            // Toggle settings modal
            settingsButton.addEventListener('click', () => {
                settingsModal.classList.add('show');
            });
            
            // Close settings modal
            if (closeSettingsButton) {
                closeSettingsButton.addEventListener('click', () => {
                    settingsModal.classList.remove('show');
                });
            }
            
            // Close settings modal with X button
            const closeXButton = document.getElementById('settings-close-x');
            if (closeXButton) {
                closeXButton.addEventListener('click', () => {
                    settingsModal.classList.remove('show');
                });
            }
            
            // Close modal when clicking outside of it
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    settingsModal.classList.remove('show');
                }
            });
            
            // Close modal when pressing Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    settingsModal.classList.remove('show');
                }
            });
            
            // Handle navigation between settings panels
            navItems.forEach(item => {
                item.addEventListener('click', () => {
                    // Update active nav item
                    navItems.forEach(nav => nav.classList.remove('active'));
                    item.classList.add('active');
                    
                    // Show corresponding panel
                    const targetPanel = document.getElementById(`${item.dataset.target}-panel`);
                    if (targetPanel) {
                        settingsPanels.forEach(panel => panel.classList.remove('active'));
                        targetPanel.classList.add('active');
                    }
                });
            });
            
            // Handle theme toggle
            darkModeBtn.addEventListener('click', () => {
                if (!darkModeBtn.classList.contains('active')) {
                    // Switch to dark mode
                    document.body.classList.add('dark-mode');
                    document.body.classList.remove('light-mode');
                    darkModeBtn.classList.add('active');
                    lightModeBtn.classList.remove('active');
                    localStorage.setItem('theme', 'dark');
                }
            });
            
            lightModeBtn.addEventListener('click', () => {
                if (!lightModeBtn.classList.contains('active')) {
                    // Switch to light mode
                    document.body.classList.add('light-mode');
                    document.body.classList.remove('dark-mode');
                    lightModeBtn.classList.add('active');
                    darkModeBtn.classList.remove('active');
                    localStorage.setItem('theme', 'light');
                }
            });
            
            // Handle font size slider
            if (fontSizeSlider) {
                fontSizeSlider.addEventListener('input', () => {
                    const fontSize = fontSizeSlider.value;
                    fontSizeValue.textContent = `${fontSize}%`;
                    document.documentElement.style.fontSize = `${fontSize}%`;
                    localStorage.setItem('fontSize', fontSize);
                });
            }
            
            // Handle max cards setting
            if (maxCardsSelect) {
                maxCardsSelect.addEventListener('change', () => {
                    const maxCards = maxCardsSelect.value;
                    localStorage.setItem('maxCards', maxCards);
                    window.maxVisibleCards = parseInt(maxCards);
                    showNotification(`Maximum cards set to ${maxCards}`);
                });
            }
            
            // Handle timestamp visibility setting
            if (showTimestampsCheckbox) {
                showTimestampsCheckbox.addEventListener('change', () => {
                    const showTimestamps = showTimestampsCheckbox.checked;
                    localStorage.setItem('showTimestamps', showTimestamps);
                    updateTimestampVisibility(showTimestamps);
                });
            }
            
            // Handle category visibility setting
            if (showCategoriesCheckbox) {
                showCategoriesCheckbox.addEventListener('change', () => {
                    const showCategories = showCategoriesCheckbox.checked;
                    localStorage.setItem('showCategories', showCategories);
                    updateCategoryVisibility(showCategories);
                });
            }
            
            // Handle completed cards section visibility setting
            if (showCompletedCardsCheckbox) {
                showCompletedCardsCheckbox.addEventListener('change', () => {
                    const showCompletedCards = showCompletedCardsCheckbox.checked;
                    localStorage.setItem('showCompletedCards', showCompletedCards);
                    updateCompletedCardsVisibility(showCompletedCards);
                    showNotification(`Completed cards section ${showCompletedCards ? 'visible' : 'hidden'}`);
                });
            }
            
            // Update timestamp visibility
            function updateTimestampVisibility(show) {
                const timestamps = document.querySelectorAll('.card-timestamp');
                timestamps.forEach(timestamp => {
                    timestamp.style.display = show ? 'block' : 'none';
                });
            }
            
            // Update category visibility
            function updateCategoryVisibility(show) {
                const categories = document.querySelectorAll('.card-tag');
                categories.forEach(category => {
                    category.style.display = show ? 'inline-block' : 'none';
                });
            }
            
            // Update completed cards section visibility
            function updateCompletedCardsVisibility(show) {
                const completedSection = document.querySelector('.completed-cards-section');
                if (completedSection) {
                    // If we should hide the section, set to 'none'
                    // Otherwise, we'll let the updateCompletedCount function handle it based on count
                    if (!show) {
                        completedSection.style.display = 'none';
                    } else {
                        // Call updateCompletedCount to set proper visibility based on count
                        updateCompletedCount();
                    }
                }
            }
            
            // Handle data export
            const exportDataBtn = document.getElementById('export-data');
            if (exportDataBtn) {
                exportDataBtn.addEventListener('click', () => {
                    const cardsData = localStorage.getItem(STORAGE_KEY);
                    if (cardsData) {
                        const blob = new Blob([cardsData], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `task_cards_backup_${new Date().toISOString().split('T')[0]}.json`;
                        document.body.appendChild(a);
                        a.click();
                        
                        setTimeout(() => {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }, 0);
                        
                        showNotification('Data exported successfully!');
                    } else {
                        showNotification('No data to export');
                    }
                });
            }
            
            // Handle data import
            const importDataBtn = document.getElementById('import-data');
            if (importDataBtn) {
                importDataBtn.addEventListener('click', () => {
                    // Create a file input element
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = '.json';
                    
                    fileInput.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const data = JSON.parse(event.target.result);
                                // Validate the data format (basic check)
                                if (Array.isArray(data) && data.length > 0 && data[0].hasOwnProperty('title')) {
                                    // Store the imported data
                                    localStorage.setItem(STORAGE_KEY, event.target.result);
                                    showNotification('Data imported successfully! Reloading...');
                                    
                                    // Reload the page after a short delay
                                    setTimeout(() => {
                                        window.location.reload();
                                    }, 1500);
                                } else {
                                    showNotification('Invalid data format');
                                }
                            } catch (error) {
                                showNotification('Error importing data: ' + error.message);
                            }
                        };
                        reader.readAsText(file);
                    });
                    
                    fileInput.click();
                });
            }
            
            // Handle data clearing
            const clearDataBtn = document.getElementById('clear-data');
            if (clearDataBtn) {
                clearDataBtn.addEventListener('click', () => {
                    if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                        localStorage.removeItem(STORAGE_KEY);
                        showNotification('All data cleared successfully!');
                        
                        // Reload the page after a short delay
                        setTimeout(() => {
                            window.location.reload();
                        }, 1500);
                    }
                });
            }
            
            // Handle calendar integration
            const calendarButtons = document.querySelectorAll('.connect-calendar-btn');
            calendarButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const provider = button.dataset.provider;
                    
                    // This would typically call an OAuth flow, which requires a backend
                    // For demo purposes, we'll simulate a successful connection
                    showNotification(`${provider.charAt(0).toUpperCase() + provider.slice(1)} Calendar integration requires backend setup`);
                    
                    // Show a modal explaining the integration process
                    const modalHTML = `
                        <div class="modal-content">
                            <h2>Calendar Integration</h2>
                            <p>Connecting to ${provider.charAt(0).toUpperCase() + provider.slice(1)} Calendar requires:</p>
                            <ul>
                                <li>Backend server for OAuth handling</li>
                                <li>API keys for ${provider} Calendar API</li>
                                <li>User authentication flow</li>
                            </ul>
                            <p>This feature would allow you to:</p>
                            <ul>
                                <li>Sync reminder cards to your calendar</li>
                                <li>Import calendar events as cards</li>
                                <li>Set up notifications for due dates</li>
                                <li>View your calendar events within the app</li>
                            </ul>
                            <p>In a production environment, this would open a secure authentication window to connect your account.</p>
                            <div class="modal-actions">
                                <button class="modal-close-btn">Close</button>
                            </div>
                        </div>
                    `;
                    
                    const modal = document.createElement('div');
                    modal.className = 'modal calendar-auth-modal';
                    modal.innerHTML = modalHTML;
                    document.body.appendChild(modal);
                    
                    // Show the modal
                    setTimeout(() => {
                        modal.classList.add('active');
                    }, 10);
                    
                    // Add close button functionality
                    const closeButton = modal.querySelector('.modal-close-btn');
                    closeButton.addEventListener('click', () => {
                        modal.classList.remove('active');
                        setTimeout(() => {
                            document.body.removeChild(modal);
                        }, 300);
                    });
                });
            });
        });

        // Add blur event listener to handle when focus is lost
        taskInput.addEventListener('blur', () => {
            // If input is empty when losing focus, ensure the indicator is hidden
            if (taskInput.value.trim() === '') {
                const inlineCategory = document.querySelector('.inline-category');
                inlineCategory.classList.remove('active', 'animate');
                taskInput.classList.remove('with-category');
            }
        });
        
        // Add focus event to update the UI state when focused
        taskInput.addEventListener('focus', () => {
            // If input has text when gaining focus, show the indicator
            if (taskInput.value.trim() !== '') {
                const predictedCategory = determineCategory(taskInput.value);
                const inlineCategory = document.querySelector('.inline-category');
                
                if (predictedCategory) {
                    inlineCategory.textContent = predictedCategory;
                    inlineCategory.classList.add('active');
                    taskInput.classList.add('with-category');
                }
            }
        });

        // Function to update the completed cards count
        function updateCompletedCount() {
            const completedContainer = document.querySelector('.completed-cards-container');
            const countElement = document.querySelector('.completed-cards-count');
            
            if (completedContainer && countElement) {
                const count = completedContainer.children.length;
                countElement.textContent = count;
                
                // Hide or show the completed section based on count AND the user preference
                const completedSection = document.querySelector('.completed-cards-section');
                if (completedSection) {
                    // Check user preference from localStorage (default to true if not set)
                    const showCompletedCards = localStorage.getItem('showCompletedCards') !== 'false';
                    
                    // Only show if both count > 0 AND user preference is to show
                    completedSection.style.display = (count > 0 && showCompletedCards) ? 'flex' : 'none';
                }
            }
        }
        
        // Function to update due date display on cards
        function updateDueDateDisplay(card, date) {
            // Remove any existing due date display
            const existingDisplay = card.querySelector('.due-date-display');
            if (existingDisplay) {
                existingDisplay.remove();
            }
            
            // Create new due date display
            const displayElement = document.createElement('div');
            displayElement.className = 'due-date-display';
            
            // Determine status (overdue, today, upcoming)
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const dueDate = new Date(date);
            dueDate.setHours(0, 0, 0, 0);
            
            const timeDiff = dueDate.getTime() - today.getTime();
            const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24));
            
            let statusClass = 'upcoming';
            let statusText = '';
            
            if (daysDiff < 0) {
                statusClass = 'overdue';
                statusText = 'OVERDUE: ';
            } else if (daysDiff === 0) {
                statusClass = 'today';
                statusText = 'DUE TODAY: ';
            }
            
            displayElement.classList.add(statusClass);
            
            // Format the date
            const options = { month: 'short', day: 'numeric' };
            if (dueDate.getFullYear() !== today.getFullYear()) {
                options.year = 'numeric';
            }
            
            const dateStr = dueDate.toLocaleDateString('en-US', options);
            
            displayElement.innerHTML = `
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="16" y1="2" x2="16" y2="6"></line>
                    <line x1="8" y1="2" x2="8" y2="6"></line>
                    <line x1="3" y1="10" x2="21" y2="10"></line>
                </svg>
                ${statusText}${dateStr}
            `;
            
            // Add to card
            const cardTitle = card.querySelector('.card-title');
            cardTitle.after(displayElement);
        }
        
        // Initialize the completed cards section
        document.addEventListener('DOMContentLoaded', () => {
            // Set up toggle for the completed cards section
            const collapseButton = document.querySelector('.collapse-completed-section');
            const completedContainer = document.querySelector('.completed-cards-container');
            
            if (collapseButton && completedContainer) {
                collapseButton.addEventListener('click', () => {
                    // Toggle collapsed state
                    completedContainer.classList.toggle('collapsed');
                    
                    // Update the button icon
                    const arrow = collapseButton.querySelector('svg polyline');
                    if (arrow) {
                        const points = completedContainer.classList.contains('collapsed') ? 
                            '6 15 12 9 18 15' : '6 9 12 15 18 9';
                        arrow.setAttribute('points', points);
                    }
                });
            }
            
            // Check for existing completed cards when loading
            updateCompletedCount();
            
            // Make the completed section draggable
            makeCompletedSectionDraggable();
        });

        // Function to make the completed cards section draggable
        function makeCompletedSectionDraggable() {
            const completedSection = document.querySelector('.completed-cards-section');
            if (!completedSection) return;
            
            let offsetX, offsetY;
            
            // Load saved position from localStorage if available
            const savedPosition = JSON.parse(localStorage.getItem('completedSectionPosition') || '{}');
            if (savedPosition.left && savedPosition.top) {
                completedSection.style.left = savedPosition.left;
                completedSection.style.top = savedPosition.top;
                completedSection.style.right = 'auto';
                completedSection.style.bottom = 'auto';
            }
            
            // Only make the header draggable to avoid interfering with card interactions
            const sectionHeader = completedSection.querySelector('.completed-section-header');
            if (!sectionHeader) return;
            
            sectionHeader.addEventListener('mousedown', function(e) {
                // Don't drag when clicking the collapse button
                if (e.target.closest('.collapse-completed-section')) {
                    return;
                }
                
                e.preventDefault();
                
                // Get current position
                const rect = completedSection.getBoundingClientRect();
                
                // Store the offset between mouse position and element corner
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                
                // Prepare for dragging
                completedSection.classList.add('dragging');
                completedSection.style.right = 'auto';
                completedSection.style.bottom = 'auto';
                
                // Set initial position
                updateSectionPosition(e);
                
                // Add document-level event listeners
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
            
            // Handle mousemove event
            function onMouseMove(e) {
                e.preventDefault();
                updateSectionPosition(e);
            }
            
            // Handle mouseup event
            function onMouseUp() {
                // Clean up listeners
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                
                completedSection.classList.remove('dragging');
                
                // Save the position to localStorage
                const position = {
                    left: completedSection.style.left,
                    top: completedSection.style.top
                };
                localStorage.setItem('completedSectionPosition', JSON.stringify(position));
            }
            
            // Update the section position based on mouse position
            function updateSectionPosition(e) {
                completedSection.style.left = (e.clientX - offsetX) + 'px';
                completedSection.style.top = (e.clientY - offsetY) + 'px';
            }
            
            // Add touch support for mobile devices
            sectionHeader.addEventListener('touchstart', function(e) {
                if (e.target.closest('.collapse-completed-section')) {
                    return;
                }
                
                const touch = e.touches[0];
                const rect = completedSection.getBoundingClientRect();
                
                offsetX = touch.clientX - rect.left;
                offsetY = touch.clientY - rect.top;
                
                completedSection.classList.add('dragging');
                completedSection.style.right = 'auto';
                completedSection.style.bottom = 'auto';
                
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                document.addEventListener('touchend', onTouchEnd);
            });
            
            function onTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                
                completedSection.style.left = (touch.clientX - offsetX) + 'px';
                completedSection.style.top = (touch.clientY - offsetY) + 'px';
            }
            
            function onTouchEnd() {
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
                
                completedSection.classList.remove('dragging');
                
                // Save the position to localStorage
                const position = {
                    left: completedSection.style.left,
                    top: completedSection.style.top
                };
                localStorage.setItem('completedSectionPosition', JSON.stringify(position));
            }
        }

        // Function to create a new card
        function createCard(text, color) {
            // Check if we've reached the limit
            const currentCardCount = document.querySelectorAll('.card').length;
            if (currentCardCount >= maxVisibleCards) {
                showNotification(`You've reached the maximum card limit of ${maxVisibleCards}!`);
                return null;
            }
            
            cardCount++;
            
            // Determine the appropriate category based on the text content
            const category = determineCategory(text);
            
            // Prepare a title - use the text if short, otherwise shorten it
            let title = text;
            if (text.length > 40) {
                title = text.substring(0, 37) + '...';
            }
            
            // Format current date and time
            const dateTime = formatDateTime();
            
            // Get color index for the current color
            const colorIndex = cardColors.indexOf(color);
            
            // Create new card element
            const card = document.createElement('div');
            card.className = `card card-type-${category.toLowerCase()}`;
            card.dataset.index = cardCount;
            card.dataset.colorIndex = colorIndex;
            card.dataset.category = category;
            card.dataset.moved = 'false';
            card.style.background = color;
            
            // Set text color based on background
            const textColor = getTextColorForBackground(color);
            card.style.color = textColor;
            
            // Check if new cards should be collapsed by default
            const collapseNewCards = localStorage.getItem('collapseNewCards') === 'true';
            
            // Prepare card content based on category
            let categoryIcon = '';
            let specialContent = '';
            let ctaText = 'Add step';
            let emptyStateText = 'Add steps to complete your task';
            
            // Category-specific customizations
            switch(category) {
                case 'Task':
                    categoryIcon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M9 11l3 3L22 4"></path>
                            <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
                        </svg>
                    `;
                    ctaText = 'Add step';
                    emptyStateText = 'Add steps to complete your task';
                    break;
                    
                case 'Reminder':
                    categoryIcon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M10 2v2"></path>
                            <path d="M6 6l-2-2"></path>
                            <path d="M14 6l2-2"></path>
                            <circle cx="10" cy="10" r="7"></circle>
                            <path d="M10 6v5l3 3"></path>
                        </svg>
                    `;
                    ctaText = 'Add date';
                    emptyStateText = 'Add important dates or times';
                    
                    // Extract date if present in text
                    const dateMatch = text.match(/\b(tomorrow|today|next week|on (mon|tues|wednes|thurs|fri|satur|sun)day|in \d+ days|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/i);
                    const timeMatch = text.match(/\b(at|by) (\d{1,2})(:|\.)?(\d{2})?(am|pm)?\b/i);
                    
                    if (dateMatch || timeMatch) {
                        const reminderDate = dateMatch ? dateMatch[0] : '';
                        const reminderTime = timeMatch ? timeMatch[0] : '';
                        
                        specialContent = `
                            <div class="reminder-datetime">
                                ${reminderDate ? `<span class="reminder-date">${reminderDate}</span>` : ''}
                                ${reminderTime ? `<span class="reminder-time">${reminderTime}</span>` : ''}
                            </div>
                        `;
                    }
                    break;
                    
                case 'Note':
                    categoryIcon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"></path>
                            <path d="M14 2v6h6"></path>
                            <path d="M16 13H8"></path>
                            <path d="M16 17H8"></path>
                            <path d="M10 9H8"></path>
                        </svg>
                    `;
                    ctaText = 'Add note';
                    emptyStateText = 'Capture your thoughts here';
                    break;
                    
                case 'Idea':
                    categoryIcon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2a7 7 0 0 1 7 7c0 2.5-2 4.5-3 6.5-1 2-1 3-1 4.5-2 0-4 0-6 0 0-1.5 0-2.5-1-4.5-1-2-3-4-3-6.5a7 7 0 0 1 7-7Z"></path>
                            <path d="M9 16a3 3 0 0 0 6 0"></path>
                        </svg>
                    `;
                    ctaText = 'Add point';
                    emptyStateText = 'Expand on your idea';
                    break;
                    
                case 'Meeting':
                    categoryIcon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                    `;
                    ctaText = 'Add agenda item';
                    emptyStateText = 'Add meeting agenda items or notes';
                    break;
                    
                case 'Goal':
                    categoryIcon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="6"></circle>
                            <circle cx="12" cy="12" r="2"></circle>
                        </svg>
                    `;
                    ctaText = 'Add milestone';
                    emptyStateText = 'Break down your goal into milestones';
                    break;
                    
                case 'Work':
                    categoryIcon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect>
                            <path d="M16 21V5a2 2 0 00-2-2h-4a2 2 0 00-2 2v16"></path>
                        </svg>
                    `;
                    ctaText = 'Add item';
                    emptyStateText = 'List work tasks or deliverables';
                    break;
                    
                case 'Travel':
                    categoryIcon = `
                        <svg class="category-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 17h18"></path>
                            <path d="m16 10-4-4-4 4"></path>
                            <path d="M12 6v9"></path>
                        </svg>
                    `;
                    ctaText = 'Add destination';
                    emptyStateText = 'Add destinations or travel items';
                    break;
                    
                default:
                    categoryIcon = '';
                    ctaText = 'Add step';
                    emptyStateText = 'Add steps to complete';
            }
            
            // Create card content
            card.innerHTML = `
                <div class="card-header">
                    <span class="card-tag">${categoryIcon}${category}</span>
                    <div class="card-header-controls">
                        <button class="card-due-date" title="Set due date">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="16" y1="2" x2="16" y2="6"></line>
                                <line x1="8" y1="2" x2="8" y2="6"></line>
                                <line x1="3" y1="10" x2="21" y2="10"></line>
                            </svg>
                        </button>
                        <button class="card-priority-flag" title="Set priority">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path>
                                <line x1="4" y1="22" x2="4" y2="15"></line>
                            </svg>
                        </button>
                        <button class="card-complete-button" title="Mark as completed">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20 6L9 17l-5-5"></path>
                            </svg>
                        </button>
                        <button class="toggle-collapse">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="18 15 12 9 6 15"></polyline>
                            </svg>
                        </button>
                        <button class="delete-card">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                </div>
                <h2 class="card-title" contenteditable="true">${title}</h2>
                ${specialContent}
                <div class="task-list-container">
                    <ul class="task-list"></ul>
                    <div class="empty-task-list">
                        <svg viewBox="0 0 24 24" fill="none" stroke-width="1.5">
                            <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"></path>
                            <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                        </svg>
                        <p>${emptyStateText}</p>
                    </div>
                    <div class="scroll-indicator"></div>
                </div>
                <button class="add-step">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                    ${ctaText}
                </button>
                <div class="card-footer">
                    <div class="color-picker" style="background: ${color};"></div>
                    <div class="card-timestamp">${dateTime.fullStr}</div>
                </div>
            `;
            
            // Apply collapse setting if enabled
            if (collapseNewCards) {
                card.classList.add('collapsed');
                // Update the toggle collapse button to show the collapsed state
                setTimeout(() => {
                    const toggleCollapseButton = card.querySelector('.toggle-collapse svg polyline');
                    if (toggleCollapseButton) {
                        toggleCollapseButton.setAttribute('points', '6 9 12 15 18 9');
                    }
                }, 0);
            }
            
            // Add category-specific event listeners and behavior
            if (category === 'Reminder') {
                const taskList = card.querySelector('.task-list');
                
                // If there's no explicit reminder date/time in the text, add a date picker
                if (!specialContent) {
                    setTimeout(() => {
                        // Add a default reminder date item
                        const today = new Date();
                        const tomorrow = new Date(today);
                        tomorrow.setDate(tomorrow.getDate() + 1);
                        
                        const dateStr = tomorrow.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                        
                        const newItem = document.createElement('li');
                        newItem.className = 'task-item date-item';
                        newItem.innerHTML = `
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                                <line x1="16" y1="2" x2="16" y2="6"></line>
                                <line x1="8" y1="2" x2="8" y2="6"></line>
                                <line x1="3" y1="10" x2="21" y2="10"></line>
                            </svg>
                            <div class="date-text" contenteditable="true">${dateStr}</div>
                        `;
                        
                        taskList.appendChild(newItem);
                        
                        // Show the task list and hide empty state
                        const emptyState = card.querySelector('.empty-task-list');
                        if (emptyState) {
                            emptyState.style.display = 'none';
                        }
                    }, 100);
                }
            }
            
            // Add special handling for Note cards to behave more like a text area
            if (category === 'Note') {
                // Create a note area that's more text-friendly
                setTimeout(() => {
                    const taskList = card.querySelector('.task-list');
                    const noteArea = document.createElement('div');
                    noteArea.className = 'note-content';
                    noteArea.setAttribute('contenteditable', 'true');
                    noteArea.setAttribute('placeholder', 'Write your notes here...');
                    
                    // Replace task list with note area
                    taskList.parentNode.insertBefore(noteArea, taskList);
                    taskList.style.display = 'none';
                    
                    // Hide empty state
                    const emptyState = card.querySelector('.empty-task-list');
                    if (emptyState) {
                        emptyState.style.display = 'none';
                    }
                    
                    // Focus the note area
                    noteArea.focus();
                }, 100);
            }
            
            // Setup all event listeners
            setupCardEvents(card);
            
            // Add card to container
            cardsStack.appendChild(card);
            
            // Add event listener for the complete button
            const completeButton = card.querySelector('.card-complete-button');
            if (completeButton) {
                completeButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent card dragging
                    
                    // Toggle completed state
                    const isCompleted = !card.classList.contains('completed');
                    
                    if (isCompleted) {
                        // Mark as completed
                        card.classList.add('completed');
                        
                        // If the card is not already collapsed, collapse it
                        if (!card.classList.contains('collapsed')) {
                            card.classList.add('collapsed');
                            
                            // Update toggle collapse button icon
                            const toggleCollapseButton = card.querySelector('.toggle-collapse svg polyline');
                            if (toggleCollapseButton) {
                                toggleCollapseButton.setAttribute('points', '6 9 12 15 18 9');
                            }
                        }
                        
                        // Move to completed section
                        const completedContainer = document.querySelector('.completed-cards-container');
                        if (completedContainer) {
                            // Remove any positioning
                            card.dataset.moved = 'false';
                            card.style.position = '';
                            card.style.left = '';
                            card.style.top = '';
                            
                            // Move to completed section
                            completedContainer.appendChild(card);
                            
                            // Update the count
                            updateCompletedCount();
                            
                            // Update card stack positions to bring next card forward
                            reindexCards();
                            updateCardStackPositions();
                        }
                        
                        
                        showNotification('Card marked as completed!');
                    } else {
                        // Mark as incomplete
                        card.classList.remove('completed');
                        
                        // Move back to main stack
                        const cardsStack = document.querySelector('.cards-stack');
                        if (cardsStack) {
                            cardsStack.appendChild(card);
                            
                            // Update the card positions
                            reindexCards();
                            updateCardStackPositions();
                            
                            // Update the count
                            updateCompletedCount();
                        }
                        
                        showNotification('Card reopened');
                    }
                    
                    // Update the tooltip
                    completeButton.title = isCompleted ? 'Mark as incomplete' : 'Mark as completed';
                    
                    // Update the storage
                    saveCardsToStorage();
                });
            }
            
            // Position all cards
            updateCardStackPositions();
            
            // Save to storage
            saveCardsToStorage();
            
            return card;
        }

        // Function to clean up any ghost cards
        function cleanupGhostCards() {
            // Remove any cards with zero opacity that aren't being animated
            const cards = document.querySelectorAll('.card');
            cards.forEach(card => {
                const opacity = parseFloat(getComputedStyle(card).opacity);
                // If the card is nearly invisible and not being interacted with
                if (opacity < 0.1 && !card.classList.contains('dragging')) {
                    card.remove();
                }
            });
            
            // Update positions and save if updateCardStackPositions is defined
            if (typeof updateCardStackPositions === 'function') {
                updateCardStackPositions();
            }
        }

        // Function to make a card draggable
        function makeDraggable(card) {
            let offsetX, offsetY;
            
            // Handle mousedown event
            card.addEventListener('mousedown', function(e) {
                // Don't drag when clicking interactive elements
                if (e.target.closest('.delete-card, .toggle-collapse, .task-checkbox, .delete-task, .add-step, .color-picker, [contenteditable="true"]')) {
                    return;
                }
                
                e.preventDefault();
                
                // Get the card's current position
                const rect = card.getBoundingClientRect();
                
                // Store the offset between mouse position and card corner
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                
                // Prepare card for dragging - absolute positioning is key
                card.classList.add('positioned');
                card.classList.add('dragging');
                card.dataset.moved = 'true';
                card.style.position = 'fixed'; // Use fixed to avoid scrolling issues
                card.style.margin = '0';
                card.style.transform = 'none'; // Clear transforms
                
                // Set initial position
                updateCardPosition(e);
                
                // Add document-level event listeners
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
            
            // Handle mousemove event
            function onMouseMove(e) {
                e.preventDefault();
                updateCardPosition(e);
            }
            
            // Handle mouseup event
            function onMouseUp(e) {
                // Clean up listeners
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                
                card.classList.remove('dragging');
                
                // Make sure the card stays positioned
                card.classList.add('positioned');
                card.dataset.moved = 'true';
                
                // Save the final position
                saveCardsToStorage();
            }
            
            // Helper function to update card position during drag
            function updateCardPosition(e) {
                card.style.left = (e.clientX - offsetX) + 'px';
                card.style.top = (e.clientY - offsetY) + 'px';
            }
            
            // Add touch support
            card.addEventListener('touchstart', function(e) {
                // Don't drag when touching interactive elements
                if (e.target.closest('.delete-card, .toggle-collapse, .task-checkbox, .delete-task, .add-step, .color-picker, [contenteditable="true"]')) {
                    return;
                }
                
                e.preventDefault();
                
                const touch = e.touches[0];
                const rect = card.getBoundingClientRect();
                
                // Store the offset between touch position and card corner
                offsetX = touch.clientX - rect.left;
                offsetY = touch.clientY - rect.top;
                
                // Prepare card for dragging
                card.classList.add('positioned');
                card.classList.add('dragging');
                card.dataset.moved = 'true';
                card.style.position = 'fixed'; // Use fixed for touch too
                card.style.margin = '0';
                card.style.transform = 'none'; // Clear transforms
                
                // Set initial position
                updateTouchPosition(touch);
                
                // Add document-level touch event listeners
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                document.addEventListener('touchend', onTouchEnd);
            }, { passive: false });
            
            // Handle touchmove event
            function onTouchMove(e) {
                e.preventDefault();
                updateTouchPosition(e.touches[0]);
            }
            
            // Handle touchend event
            function onTouchEnd() {
                // Clean up listeners
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
                
                card.classList.remove('dragging');
                
                // Make sure the card stays positioned
                card.classList.add('positioned');
                card.dataset.moved = 'true';
                
                // Save the final position
                saveCardsToStorage();
            }
            
            // Helper function to update card position during touch
            function updateTouchPosition(touch) {
                card.style.left = (touch.clientX - offsetX) + 'px';
                card.style.top = (touch.clientY - offsetY) + 'px';
            }
        }

        // ... existing code ...
        document.addEventListener('DOMContentLoaded', function() {
            // ... existing code ...

            // Add validation for time inputs
            const hoursInput = document.getElementById('hours');
            const minutesInput = document.getElementById('minutes');
            
            hoursInput.addEventListener('input', function() {
                const value = parseInt(this.value) || 0;
                if (value < 1) this.value = 1;
                if (value > 12) this.value = 12;
            });
            
            minutesInput.addEventListener('input', function() {
                const value = parseInt(this.value) || 0;
                if (value < 0) this.value = 0;
                if (value > 59) this.value = 59;
                
                // Always display with leading zero
                if (value < 10) {
                    this.value = this.value.padStart(2, '0');
                }
            });
            
            // Format minutes with leading zeros when blurring
            minutesInput.addEventListener('blur', function() {
                const value = parseInt(this.value) || 0;
                this.value = value.toString().padStart(2, '0');
            });
            
            // Add event listener for the date picker close button
            const closeBtn = document.getElementById('date-picker-close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', function() {
                    closeDateTimePicker();
                });
            }
            
            // Add event listener for the date picker cancel button
            const cancelBtn = document.getElementById('date-picker-cancel-btn');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', function() {
                    closeDateTimePicker();
                });
            }
            
            // ... existing code ...
        });
    </script>
    
    <!-- Date Time Picker -->
    <div class="date-picker-container" id="date-time-picker" style="display: none;">
        <div class="date-picker-header">
            <h4>Set Reminder</h4>
            <button class="date-picker-close" id="date-picker-close-btn">×</button>
        </div>
        
        <div class="date-picker-calendar" id="calendar-container">
            <!-- Calendar will be injected here -->
        </div>
        
        <div class="time-picker-container">
            <div class="time-picker-inputs">
                <input type="number" class="time-input" id="hours" min="1" max="12" value="12">
                <span class="time-separator">:</span>
                <input type="number" class="time-input" id="minutes" min="0" max="59" value="00">
                <select class="time-period" id="period">
                    <option value="AM">AM</option>
                    <option value="PM">PM</option>
                </select>
            </div>
        </div>
        
        <div class="reminder-selector">
            <select id="reminder-select" class="reminder-dropdown">
                <option value="none">No reminder</option>
                <option value="5">5 min before</option>
                <option value="15">15 min before</option>
                <option value="30">30 min before</option>
                <option value="60">1 hour before</option>
            </select>
        </div>
        
        <div class="date-picker-actions">
            <button class="date-picker-btn secondary" id="date-picker-cancel-btn">Cancel</button>
            <button class="date-picker-btn primary" onclick="setDateTime()">Set</button>
        </div>
    </div>
<script src="flag_priority.js"></script>
</body>
</html>
